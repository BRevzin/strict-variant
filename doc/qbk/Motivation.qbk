[section Abstract and Motivation]

[h3 Abstract]

`strict_variant` is a safe and performant discriminated union container, in the
style of `boost::variant`, designed for the C++11 standard.

[h3 Motivation]

`strict_variant` was created primarily to improve on some aspects of `boost::variant`:

* Too easy to cause implicit conversions
* Too easy to cause implementation-dependent conversions
* Makes backup copies of your objects under the hood
* Somewhat complex implementation (not always easy to understand when a backup copy will be made)

while maintaining the "never-empty" property, which was dropped in `std::variant` and many
of the other open-source `variant` implementations.

To summarize the differences:

* `std::variant` is rarely-empty, always stack-based. In fact, it's empty exactly
  when an exception is thrown. Later, it throws different exceptions if you try to visit
  when it is empty.
* `boost::variant` is never-empty, usually stack-based. It has to make a dynamic allocation
  and a backup copy whenever an exception *could* be thrown, but that gets freed right after
  if an exception is not actually thrown.
* `strict_variant` is never-empty, and stack-based exactly when the current value-type is
  nothrow moveable. It never makes a backup move or copy, and never throws an exception.
   
Each approach has its merits. I chose the `strict_variant` approach because I find it
simpler and it avoids what I consider to be drawbacks of `boost::variant` and `std::variant`. 

And, if you manage
to make all your types no-throw move constructible, which I often find I can, then `strict_variant`
gives you optimal performance, the same as `std::variant`, without an empty state.

[h3 Goals]

The design goals of `strict_variant` are:

* Provide a variant type which is strongly exception safe and never-empty.
* Make it as convenient and easy to use as `boost::variant`.
* Avoid the overhead of copies and dynamic allocations to the extent
  possible within these constraints.
* Favor an implementation which will be easy for the programmer to understand.
* Avoid "unexpected" and/or non-portable implicit conversions of fundamental
  types during variant assignment, to increase type-safety when using the variant.

[endsect]
