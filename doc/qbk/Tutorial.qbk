[section Basic Usage]

The "basic usage" of `strict_variant::variant` mirrors exactly the usage of
`boost::variant`. If you are not familiar with `boost::variant`, I suggest
you have a look at [@boost:/doc/html/variant/tutorial.html#variant.tutorial.basic their tutorial] first.

[endsect]

[section Advanced Usage]

[h3 More general visitors]

One thing which you'll note in `boost::variant` docs is that when applying a
visitor, they always derive from `boost::static_visitor`, or explicitly define
a typedef `result_type`.

In `strict_variant`, this isn't necessary, the return type will be deduced.

In particular, this means that you can use lambdas as visitors, like so:

```
  strict_variant::variant<int, float> v;
  v = 5;

  // Prints 10.0
  std::cout << strict_variant::apply_visitor([](double d) -> double { return d * 2; }, v) << std::endl;

  v = 7.5

  // Prints 22.5
  std::cout << strict_variant::apply_visitor([](double d) -> double { return d * 3; }, v) << std::endl;
```

One feature of `boost::variant` which we ['don't currently support] is ['delayed visitation]. For this, you will
have to use a capturing lambda or some other sort of ad-hoc function object.

[h3 Recursive variants]

`strict_variant` has full support for recursive variants, using `strict_variant::recursive_wrapper`.
This is used in essentially the same way as `boost::recursive_wrapper`.

We don't provide any analogue of `boost::make_recursive_variant`.

[h3 Multivisitation]

`strict_variant` has full support for visiting 2 or more variants simultaneously, just as `boost::variant` does.

However for this you must include `<strict_variant/multivisit.hpp>`.

[h3 Assignment]

Just like `boost::variant` and any other standard container, `strict_variant` can be moved, copied and assigned.

However, like `boost::variant` it has some restrictions.

`boost::variant` requires that all its constituent types satisfy
the `Bounded Type` concept, which required that they are no-throw destructible, copy constructible or move constructible.

`strict_variant` requires that its constituent types are no-throw destructible.

Further, `strict_variant` is only assignable if the constituent types are all nothrow move constructible.

Since that's not always possible for the types you may want to use it with, there are a few handy solutions.

Suppose that our goal is code like this:

```
// A class with a throwing move
class X {
  std::string foo;

public:
  X ();
  X (const X &);
  X (X &&) = delete;
};

// A variant containing X
int main() {
  strict_variant::variant<int, X> v;
  v = 5;
  v = X();
}

```

This code will fail to compile, because `v` cannot be assigned if `X` has a throwing move.
We have a few possible remedies:

# Use `recursive_wrapper` with types that have throwing moves.
  ```
  int main() {
    strict_variant::variant<int, strict_variant::recursive_wrapper<X>> v;
    v = 5;
    v = X();
  }
  ```

# Use `easy_variant` instead of `strict_variant`. It's the same, but it implicitly applies wrappers to its arguments with throwing moves.
  ```
  int main() {
    strict_variant::easy_variant<int, X> v;
    v = 5;
    v = X();
  }
  ```

# Don't use assignment, and use the `emplace` method instead.
  ```
  int main() {
    strict_variant::variant<int, X> v;
    v.emplace<int>(5);
    v.emplace<X>();
  }
  ```

[endsect]
