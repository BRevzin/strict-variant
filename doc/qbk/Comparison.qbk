[section:comparison Comparison]

Because our `recusrive_wrapper` type is no-throw move constructible, this
effectively

It's primary advantages over `boost::variant` are that it does not require your objects
to be copyable, nor does it rely on making backup copies, and it's implementation
is somewhat simpler which may make it a little easier to reason about what
happens under the hood when you use it.

It's primary difference over the `std::variant` type which was introduced in C++17
is that it provides a never-empty guarantee, like `boost::variant`. In some
applications this makes it somewhat simpler to use correctly. The trade-off
essentially is that for less the well-behaved types that can lead to empty
states, we compromise on the "stack-based" property of `variant` and allocate
them on the heap instead, in order to provide *strong exception safety* and a
simpler interface.

[endsect]
