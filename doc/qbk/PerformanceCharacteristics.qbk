[section Comparison and Performance Characteristics]

[h3 Assignment]

The main point of variation among variant types is usually how they handle the
never-empty guarantee.  (Beyond that, they often vary significantly in how they
actually implement the storage, especially if they seek `constexpr` support.)

[h4 `boost::variant]

In `boost::variant`, the strategy is to make a heap-allocated backup copy of the
value, and then destroy the original and attempt to allocate the new value in the
in situ storage. If that operation throws, then the heap-allocated copy still
exists, and subsequent uses point to that. Any later type-changing assignments
will try to take place in situ, and the heap-allocated backup will remain until
one of those succeeds.

This provides the most comprehensive support, but it incurs an extra copy and
an extra dynamic allocation for each assignment. There's also some space overhead
for the pointer.

The copy may be particularly unattractive because while sometimes a value is
entirely "self-contained", sometimes the object that we put in the variant may
be connected to other components of our program, and copying it may have nontrivial
side-effects. For instance, it may have to talk to a manager, or increment
reference counters for resources, or talk to a number of subsidiary objects,
when it is copied. Even if this isn't a performance concern, it may be confusing
for the programmer who isn't intimately familiar with the implementation details
of `boost::variant`. "I assigned a `B` to the variant, so why did that trigger
a copy constructor for unrelated type `A` and all of these side-effects?".

Granted, when `boost::variant` is compiled at C++11 standard, this copy may be
a move instead, and then such side effects are much less likely.

However, even a backup-move has the drawback that the `move` itself may throw an
exception. That is, when assigning `B` to the variant, an exception may result
from `A` being moved out of storage, which may be counter-intuitive for the
programmer.

If I have a variant

```
  boost::variant<X, Y> v;
```

where `X` and `Y` have a throwing move, ideally, it would be true that 

```
  v = Y();
```

can only throw exceptions generated by `Y`. But with `boost::variant`, this isn't
true, the assignment can generate exceptions thrown by `X` or by `Y`.

# `X` is moved onto the heap. (Dynamic allocation may throw, `X`'s move may throw.)
# `X` in storage is destroyed (noexcept)
# `Y` is moved into storage (may throw a `Y` exception)

This is what happens with `strict_variant`.

# `Y` is moved onto the heap. (Dynamic allocation may throw, `Y`'s move may thorw.)
# `X` in storage is destroyed (noexcept)
# Pointer to `Y` moved into storage (noexcept).

In both cases, there is a dynamic allocation, but `strict_variant` only causes
one move rather than two, and only exceptions related to the object that we
are creating can be thrown.

This means that if we need to perform `v = Y();` in a place where any exceptions
have to be handled on-site, it's much simpler and we have many fewer possibilities
to handle. And the code won't necessarily need fixup if we later add more types
to the `variant`.

A drawback of `strict_variant` here is that when we try to visit the variant
later, it's slower because the value is on the heap rather than in situ.
`boost::variant` really tries hard to get the value in situ -- that's basically
the source of the complexity relative to `strict_variant`.

In `boost::variant`, the value may still end up being on the heap permanently,
if an exception was thrown. So if this happens frequently, then you are already
paying this penalty.

The main points in favor of `strict_variant` here are:

# With the `strict_variant`, there are no dynamic allocations that you don't
  explicitly opt-in to, using the `recursive_wrapper`.
  So if it's important to you to avoid this, it's not built-in to the variant
  and it won't happen silently.
# With the `boost::variant` method, you may end up with extra storage space
  used for the pointer to the backup dynamic allocation. With the
  `strict_variant` method, basically this pointer ends up in the storage rather
  than along-side the storage.
# We hope to make up any ground lost in visitation speed by using a different
  visitor dispatch mechanism -- many modern variadic-variant implementations
  use a dispatch method that sometimes ends up generating an extra call to a
  function pointer whenever the `variant` is visited, which cannot always be
  inlined by compilers like `gcc` and `clang`.
  `strict_variant` uses a different approach which is a bit more complicated,
  but with the result that this function can always be inlined. See next section
  for more details.

[h4 `std::variant`]

In the C++17 `std::variant`, the strategy is to relax the never-empty guarantee
to a "rarely empty" guarantee, by introducing an empty state which occurs when
construction fails. This greatly simplifies assignment and makes that more efficient,
but it may complicate visitation, depending on how concerned you are about the
empty state. In essence we are sacrificing strong exception safety for only
basic exception safety, in a quest for performance.

In `strict_variant`, the focus is on a less general case. We basically "favor"
the nothrow move-constructible members, which enjoy optimal performance like they
would in `std::variant`. In `easy_variant`, we accomodates all members with
throwing move by putting them on the heap -- then the pointer can be moved into
storage without failure.

Basically, the cost of `std::variant` is that you have to put up with an empty
state. If you don't actually have any throwing moves in your variant, then you
still end up "paying for what you don't use" in some sense because of the added
interface complexity, the fact that the compiler may deduce `apply_visitor` to
be potentially throwing even if the visitor itself is `noexcept`, etc.

Besides this, `strict_variant` can be used even on old compilers like `gcc 4.8`
and `clang 3.5`, and at C++11 standard, which makes it more appropriate for some
projects.

[h3 Visitation]

The other major point of variation among variant implementations is the speed of
visitation.

In `boost::variant`, at least the early implementations used `boost::mpl`, and
were limited to twenty or so types. `boost::variant` works even prior to the
variadic templates feature. Doing without variadic templates makes the header
pretty complicated and hurts the compile times, but it's very helpful to speed
of visitation, which can be done using an explicit `switch` statement.

In a variadic template-based implementation, switch statements cannot be used,
because there is no pack-expansion analogue for switch statements. The most
common strategy that I saw is to declare an array of function pointers, and
fill it with a series of instantiations of a template function. Each pointer
corresponds to an one of the input types. Then this array is indexed
and the appropriate function pointer is called, passing along the visitor,
the variant storage, etc. The array thus forms a little manual jump table of
sorts.

This implementation is pretty straightforward, but it has the drawback that the
function pointers cannot always be inlined by the compiler,
and so for relatively small numbers of elements, it can be outperformed by
other strategies.

In a second strategy, a binary tree is formed which holds at
each leaf one of the input types. We then search the binary tree using the
"which" value which would have been the index to the jump table. When we arrive
at the leaf, we know the runtime-type of the value, and can invoke the visitor
appropriately. This implementation involves no function pointers, so the calls
can always be inlined -- but it may involve several branches. However, these
branches may benefit from branch prediction, and in practice, its quite common
to have variants with only a handful of types. Particularly when there is one
type which is the "most popular", branch prediction can significantly speed up
the visitation well beyond what you will see in benchmarks with random data,
which are already quite favorable to the "binary" search strategy for small
numbers of types. This is the strategy currently used by `strict_variant`.

A third strategy, naive tail recursion, is used by `mapbox::variant`.
Surprisingly (for me), this is the best performing strategy, for both `gcc` and
`clang` and all regimes, according to most recent benchmark investigations.

See the next section for benchmark data.

[h3 Compile-Times]

I did not attempt to benchmark the compile-time performance, but I expect that
the differences would be negligible, especially in comparison to other common
libraries which are known to have heavy compile times.

[endsect]
