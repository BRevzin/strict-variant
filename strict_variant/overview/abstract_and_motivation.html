<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Abstract and Motivation</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Strict Variant 0.3">
<link rel="up" href="../overview.html" title="Overview">
<link rel="prev" href="../overview.html" title="Overview">
<link rel="next" href="design.html" title="Design">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="design.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="strict_variant.overview.abstract_and_motivation"></a><a class="link" href="abstract_and_motivation.html" title="Abstract and Motivation">Abstract
      and Motivation</a>
</h3></div></div></div>
<h4>
<a name="strict_variant.overview.abstract_and_motivation.h0"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.abstract"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.abstract">Abstract</a>
      </h4>
<p>
        <code class="computeroutput"><span class="identifier">strict_variant</span></code> is a safe
        and performant discriminated union container, in the style of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, designed for the C++11 standard.
      </p>
<h4>
<a name="strict_variant.overview.abstract_and_motivation.h1"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.motivation"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.motivation">Motivation</a>
      </h4>
<p>
        <code class="computeroutput"><span class="identifier">strict_variant</span></code> is similar
        in design to <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, however, there are a few important
        changes to the <span class="bold"><strong>interface</strong></span> and the <span class="bold"><strong>implementation</strong></span>. The basic goal is to make it more
        convenient for the programmer to use -- debatably there are some efficiency
        gains in some situations, but that's not the primary goal.
      </p>
<h5>
<a name="strict_variant.overview.abstract_and_motivation.h2"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.interface"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.interface">Interface</a>
      </h5>
<p>
        Both <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code>
        support construction from any instance of one of the value types, or any
        type convertible to one of the value types. In <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>,
        even C++03 is supported, so in that case there actually is one constructor
        for each value type. In C++17 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code>,
        it is specified that when constructing a variant from a value, the value-type
        / conversion which will be used is determined by overload resolution, essentially
        the same mechanism.
      </p>
<p>
        However, this behavior is somewhat inconvenient in some scenarios. For instance,
        this code compiles just fine, though we might not want it to:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="identifier">v</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span> <span class="comment">// bool -&gt; int conversion is selected</span>
</pre>
<p>
        and this code fails because of ambiguous overload resolution:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="keyword">long</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="identifier">v</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span> <span class="comment">// int -&gt; long and int -&gt; ull are equally good conversions</span>
</pre>
<p>
        Another, slightly different example. This code does what you expect:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="identifier">v</span> <span class="special">=</span> <span class="string">"The future is now!"</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">which</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
        When tested with <code class="computeroutput"><span class="identifier">boost</span> <span class="number">1.58</span></code>
        and <code class="computeroutput"><span class="identifier">gcc</span> <span class="number">5.4</span><span class="special">.</span><span class="number">0</span></code>, it outputs:
      </p>
<pre class="programlisting"><span class="number">1</span>
<span class="identifier">The</span> <span class="identifier">future</span> <span class="identifier">is</span> <span class="identifier">now</span><span class="special">!</span>
</pre>
<p>
        However, when we change it slightly, it does something totally different:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="identifier">v</span> <span class="special">=</span> <span class="string">"The future is now!"</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">which</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
        It now selects <code class="computeroutput"><span class="keyword">bool</span></code>, because
        of implicit pointer-to-bool conversions:
      </p>
<pre class="programlisting"><span class="number">0</span>
<span class="number">1</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">strict_variant</span></code> addresses
        such issues by modifying the overload resolution process. Before overload
        resolution takes place, some candidates are excluded:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            If they represent an "unsafe" conversion of fundamental types,
            it will be discarded. This includes narrowing conversions, <code class="computeroutput"><span class="keyword">unsigned</span> <span class="special">-&gt;</span>
            <span class="keyword">signed</span></code>, and conversions between
            any of the classes <code class="computeroutput"><span class="keyword">bool</span></code>,
            integral, floating point, character, and some others.
          </li>
<li class="listitem">
            If a candidate is safe, but there is a "strictly better" candidate,
            it will be dropped. In our system, for instance, lower rank candidates
            are considered better.
          </li>
</ul></div>
<p>
        For a prime use-case, you might be using the variant to represent value types
        when binding C++ code to some scripting language implementation. Many scripting
        languages support <code class="computeroutput"><span class="keyword">bool</span><span class="special">,</span>
        <span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>,
        etc. as primitive values, but basically overload resolution is most likely
        to become ambiguous in situations like this. We refine the overload resolution
        process on the <span class="emphasis"><em>assumption</em></span> that what you are trying to
        do is store the value as faithfully as possible for later recovery, while
        still permitting portable integer promotions and such.
      </p>
<p>
        For a complete description of the conversion rules, check out TODO LINK.
      </p>
<h5>
<a name="strict_variant.overview.abstract_and_motivation.h3"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.implementation"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.implementation">Implementation</a>
      </h5>
<p>
        The second way in which <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        differs from <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> is the implementation approach
        -- how exactly is the storage managed, and how is the never-empty guarantee
        achieved.
      </p>
<p>
        Much digital ink has been spilled regarding the technical difficulties of
        implementing a general, never-empty variant in C++. (For a long list of references,
        see the footnotes of the design section.)
      </p>
<p>
        At least, it's clear that there is no "perfect" solution and there
        are instead many possible compromises, most of which are incomparable.
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Should we use double storage? Should we sometimes make heap allocations?
          </li>
<li class="listitem">
            Should we make "backup copies" for exception safety, and how
            aggressively?
          </li>
<li class="listitem">
            Should we have an empty state? What should happen if we are visited or
            queried while empty?
          </li>
<li class="listitem">
            Should we throw exceptions?
          </li>
</ul></div>
<p>
        In the design section we'll discuss various options in detail, but to motivate
        our approach, we'd like to argue that an approach which <span class="emphasis"><em>requires
        as little bandwidth to explain to the programmer as possible</em></span> is
        a good one.
      </p>
<p>
        To that end, let's try to design a general <code class="computeroutput"><span class="identifier">variant</span></code>
        from the ground up by <span class="emphasis"><em>reducing the problem to a simpler one</em></span>.
      </p>
<p>
        The simpler problem is,
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            designing a <code class="computeroutput"><span class="identifier">variant</span></code> which
            is restricted to contain only value-types which are <span class="bold"><strong>nothrow
            move constructible</strong></span>.
          </li></ul></div>
<p>
        It turns out that this problem is really much simpler -- there is no longer
        any issue with the "throwing, type-changing assignment". We can
        always vacate the storage and then move the new value in, since the move
        won't throw. Compared to the general problem, this kind of variant is straightforward
        to implement optimally. Basically everything can be done by "copy and
        swap" and similar idioms -- there are no "surprises" here
        really.
      </p>
<p>
        Now,
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            how can we reduce general variant to this kind of variant?
          </li></ul></div>
<p>
        It turns out we can do it in a simple way using a little template:
      </p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="identifier">wrap_if_throwing_move_t</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">conditional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_nothrow_move_constructible</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span>
                                                          <span class="identifier">T</span><span class="special">,</span>
                                                          <span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;::</span><span class="identifier">type</span><span class="special">;</span>
</pre>
<p>
        (The reader will hopefully recall <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        from <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>.
      </p>
<p>
        A <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> represents
        a heap-allocated instance of <code class="computeroutput"><span class="identifier">T</span></code>.
        It can be used to declare a variant which morally contains a <code class="computeroutput"><span class="identifier">T</span></code> even if <code class="computeroutput"><span class="identifier">T</span></code>
        is an incomplete type.)
      </p>
<p>
        Now, for the general form of the variant, we simply apply <code class="computeroutput"><span class="identifier">wrap_if_throwing_move_t</span></code>
        to each value-type, and defer to the simpler implementation.
      </p>
<p>
        (In the <code class="computeroutput"><span class="identifier">strict_variant</span></code> library,
        the template class <code class="computeroutput"><span class="identifier">strict_variant</span><span class="special">::</span><span class="identifier">variant</span></code>
        is the "easy case" solution, and the template alias <code class="computeroutput"><span class="identifier">strict_variant</span><span class="special">::</span><span class="identifier">easy_variant</span></code> is the general-case solution.)
      </p>
<p>
        The point is that even if <code class="computeroutput"><span class="identifier">T</span></code>
        has a throwing move, <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        can always be moved into storage without throwing, because it is just a pointer.
      </p>
<p>
        Some care must be taken -- throughout the <code class="computeroutput"><span class="identifier">variant</span></code>
        interface, it is important that <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        is transparently pierced for the user, not only for convenience now, but
        for correctness -- the user should not be able to make the <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code> empty.
      </p>
<p>
        But, with adequate care for such issues, you are now perfectly capable of
        going and writing your own <code class="computeroutput"><span class="identifier">strict_variant</span></code>,
        and you'll get the same thing at least in regards to all the "controversial"
        parts of implementing a variant.
      </p>
<p>
        In fact, you could probably stop reading the documentation right now and
        go and use the variant, and hopefully wouldn't ever be surprised by it's
        behavior given what I just told you.
      </p>
<p>
        (This is not a trick -- the rest of the documentation does actually exist
        and is accurate to the best of my knowledge if you want to read it :p)
      </p>
<h5>
<a name="strict_variant.overview.abstract_and_motivation.h4"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.example"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.example">Example</a>
      </h5>
<p>
        To illustrate the differences between the <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> implementations, consider the following
        example:
      </p>
<pre class="programlisting"><span class="keyword">using</span> <span class="identifier">var_t</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="identifier">A</span><span class="special">,</span> <span class="identifier">B</span><span class="special">&gt;;</span>

<span class="identifier">var_t</span> <span class="identifier">v</span><span class="special">{</span><span class="identifier">A</span><span class="special">()};</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"1"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">v</span> <span class="special">=</span> <span class="identifier">B</span><span class="special">();</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"2"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">v</span> <span class="special">=</span> <span class="identifier">A</span><span class="special">();</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"3"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
        where <code class="computeroutput"><span class="identifier">A</span></code> and <code class="computeroutput"><span class="identifier">B</span></code> have been configured to log all ctor
        and dtor calls.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> generates the following output:
      </p>
<pre class="programlisting"><span class="identifier">A</span><span class="special">()</span>
<span class="identifier">A</span><span class="special">(</span><span class="identifier">A</span><span class="special">&amp;&amp;)</span>
<span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
<span class="number">1</span>
<span class="identifier">B</span><span class="special">()</span>
<span class="identifier">B</span><span class="special">(</span><span class="identifier">B</span><span class="special">&amp;&amp;)</span>
<span class="identifier">A</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">A</span> <span class="special">&amp;)</span>
<span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
<span class="identifier">B</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">B</span> <span class="special">&amp;)</span>
<span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
<span class="special">~</span><span class="identifier">B</span><span class="special">()</span>
<span class="special">~</span><span class="identifier">B</span><span class="special">()</span>
<span class="number">2</span>
<span class="identifier">A</span><span class="special">()</span>
<span class="identifier">A</span><span class="special">(</span><span class="identifier">A</span><span class="special">&amp;&amp;)</span>
<span class="identifier">B</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">B</span> <span class="special">&amp;)</span>
<span class="special">~</span><span class="identifier">B</span><span class="special">()</span>
<span class="identifier">A</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">A</span> <span class="special">&amp;)</span>
<span class="special">~</span><span class="identifier">B</span><span class="special">()</span>
<span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
<span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
<span class="number">3</span>
<span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
</pre>
<p>
        while <code class="computeroutput"><span class="identifier">strict_variant</span></code> generates
      </p>
<pre class="programlisting"><span class="identifier">A</span><span class="special">()</span>
<span class="identifier">A</span><span class="special">(</span><span class="identifier">A</span><span class="special">&amp;&amp;)</span>
<span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
<span class="number">1</span>
<span class="identifier">B</span><span class="special">()</span>
<span class="identifier">B</span><span class="special">(</span><span class="identifier">B</span><span class="special">&amp;&amp;)</span>
<span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
<span class="special">~</span><span class="identifier">B</span><span class="special">()</span>
<span class="number">2</span>
<span class="identifier">A</span><span class="special">()</span>
<span class="identifier">A</span><span class="special">(</span><span class="identifier">A</span><span class="special">&amp;&amp;)</span>
<span class="special">~</span><span class="identifier">B</span><span class="special">()</span>
<span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
<span class="number">3</span>
<span class="special">~</span><span class="identifier">A</span><span class="special">()</span>
</pre>
<p>
        For a programmer, this means the following:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> has to make backup copies of
            both <code class="computeroutput"><span class="identifier">A</span></code> and <code class="computeroutput"><span class="identifier">B</span></code>, while <code class="computeroutput"><span class="identifier">strict_variant</span></code>
            constructs the same number of objects as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code>
            or one of the rarely-empty variants. When debugging low-level problems,
            it may become important to know about the extra object instances -- it's
            not always "invisible" to the programmer.
          </li>
<li class="listitem">
            When I write <code class="computeroutput"><span class="identifier">v</span> <span class="special">=</span>
            <span class="identifier">A</span><span class="special">();</span></code>
            and <code class="computeroutput"><span class="identifier">v</span></code> is a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, this can throw both <code class="computeroutput"><span class="identifier">A</span></code>-exceptions and <code class="computeroutput"><span class="identifier">B</span></code>-exceptions.
            With <code class="computeroutput"><span class="identifier">strict_variant</span></code> it
            can only throw <code class="computeroutput"><span class="identifier">A</span></code>-exceptions.
          </li>
</ul></div>
<p>
        But, these issues aside, I argue that <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        adds value because the programmer can have a much simpler mental model of
        how it works and what exactly can happen when they manipulate it.
      </p>
<p>
        For an extended comparison of this and several other possible implementation
        strategies, see the design page.
      </p>
<h4>
<a name="strict_variant.overview.abstract_and_motivation.h5"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.goals"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.goals">Goals</a>
      </h4>
<p>
        The design goals of <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        are:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Provide a variant type which is strongly exception safe and never-empty.
          </li>
<li class="listitem">
            Make it as convenient and easy to use as <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>.
          </li>
<li class="listitem">
            Avoid the overhead of copies and dynamic allocations to the extent possible
            within these constraints.
          </li>
<li class="listitem">
            Favor an implementation which will be easy for the programmer to understand.
          </li>
<li class="listitem">
            Avoid "unexpected" and/or non-portable implicit conversions
            of fundamental types during variant assignment, to increase type-safety
            when using the variant.
          </li>
</ul></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="design.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
