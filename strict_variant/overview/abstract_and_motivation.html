<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Abstract and Motivation</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Strict Variant 0.3">
<link rel="up" href="../overview.html" title="Overview">
<link rel="prev" href="../overview.html" title="Overview">
<link rel="next" href="design.html" title="Design">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="design.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="strict_variant.overview.abstract_and_motivation"></a><a class="link" href="abstract_and_motivation.html" title="Abstract and Motivation">Abstract
      and Motivation</a>
</h3></div></div></div>
<h4>
<a name="strict_variant.overview.abstract_and_motivation.h0"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.abstract"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.abstract">Abstract</a>
      </h4>
<p>
        <code class="computeroutput"><span class="identifier">strict_variant</span></code> is a safe
        and performant discriminated union container, in the style of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, designed for the C++11 standard.
      </p>
<h4>
<a name="strict_variant.overview.abstract_and_motivation.h1"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.motivation"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.motivation">Motivation</a>
      </h4>
<p>
        <code class="computeroutput"><span class="identifier">strict_variant</span></code> is similar
        in design to <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, however, there are a few important
        changes to the <span class="bold"><strong>interface</strong></span> and the <span class="bold"><strong>implementation</strong></span>. The basic goal is to make it more
        convenient for the programmer to use -- debatably there are some efficiency
        gains in some situations, but that's not the primary goal.
      </p>
<h5>
<a name="strict_variant.overview.abstract_and_motivation.h2"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.interface"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.interface">Interface</a>
      </h5>
<p>
        Both <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code>
        support construction from any instance of one of the value types, or any
        type convertible to one of the value types. In <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>,
        even C++03 is supported, so in that case there actually is one constructor
        for each value type. In C++17 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code>,
        it is specified that when constructing a variant from a value, the value-type
        / conversion which will be used is determined by overload resolution, essentially
        the same mechanism.
      </p>
<p>
        However, this behavior is somewhat inconvenient in some scenarios. For instance,
        this code compiles just fine, though we might not want it to:
      </p>
<pre class="programlisting"><span class="identifier">c</span><span class="special">++</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="identifier">v</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span> <span class="comment">// bool -&gt; int conversion is selected</span>
</pre>
<p>
        and this code fails because of ambiguous overload resolution:
      </p>
<pre class="programlisting"><span class="identifier">c</span><span class="special">++</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="keyword">long</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="identifier">v</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span> <span class="comment">// int -&gt; long and int -&gt; ull are equally good conversions</span>
</pre>
<p>
        Another, slightly different example. This code does what you expect:
      </p>
<pre class="programlisting"><span class="identifier">c</span><span class="special">++</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

  <span class="identifier">v</span> <span class="special">=</span> <span class="string">"The future is now!"</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">which</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
        When tested with <code class="computeroutput"><span class="identifier">boost</span> <span class="number">1.58</span></code>
        and <code class="computeroutput"><span class="identifier">gcc</span> <span class="number">5.4</span><span class="special">.</span><span class="number">0</span></code>, it outputs:
      </p>
<pre class="programlisting"><span class="identifier">c</span><span class="special">++</span>
<span class="number">1</span>
<span class="identifier">The</span> <span class="identifier">future</span> <span class="identifier">is</span> <span class="identifier">now</span><span class="special">!</span>
</pre>
<p>
        However, when we change it slightly, it does something totally different:
      </p>
<pre class="programlisting"><span class="identifier">c</span><span class="special">++</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

  <span class="identifier">v</span> <span class="special">=</span> <span class="string">"The future is now!"</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span><span class="special">.</span><span class="identifier">which</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
  <span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
</pre>
<p>
        It now selects <code class="computeroutput"><span class="keyword">bool</span></code>, because
        of implicit pointer-to-bool conversions:
      </p>
<pre class="programlisting"><span class="identifier">c</span><span class="special">++</span>
<span class="number">0</span>
<span class="number">1</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">strict_variant</span></code> addresses
        such issues by modifying the overload resolution process. Before overload
        resolution takes place, some candidates are excluded.
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            If they represent an "unsafe" conversion of fundamental types.
            This includes narrowing conversions, <code class="computeroutput"><span class="keyword">unsigned</span>
            <span class="special">-&gt;</span> <span class="keyword">signed</span></code>,
            and conversions between any of the classes <code class="computeroutput"><span class="keyword">bool</span></code>,
            integral, floating point, character, and some others.
          </li>
<li class="listitem">
            If a candidate is safe, but there is a "strictly better" candidate,
            it will be dropped. In our system, for instance, lower rank candidates
            are considered better.
          </li>
</ul></div>
<p>
        For a prime use-case, you might be using the variant to represent value types
        when binding C++ code to some scripting language implementation. Many scripting
        languages support <code class="computeroutput"><span class="keyword">bool</span><span class="special">,</span>
        <span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>,
        etc. as primitive values, but basically overload resolution is most likely
        to become ambiguous in situations like this. We refine the overload resolution
        process on the <span class="emphasis"><em>assumption</em></span> that what you are trying to
        do is store the value as faithfully as possible for later recovery, while
        still permitting portable integer promotions and such.
      </p>
<p>
        For a complete description of the conversion rules, check out TODO LINK.
      </p>
<h5>
<a name="strict_variant.overview.abstract_and_motivation.h3"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.implementation"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.implementation">Implementation</a>
      </h5>
<p>
        The second way in which <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        differs from <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> is the implementation approach
        -- how exactly is the storage managed, and how is the never-empty guarantee
        achieved.
      </p>
<p>
        Much digital ink has been spilled regarding the technical difficulties of
        implementing a general, never-empty variant in C++. (For a long list of references
        see the footnotes of the design section.)
      </p>
<p>
        At least, it's clear that there are many possible approaches to the problem,
        most of which are incomparable, and will outperform others in various situations
        --
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Should we use double storage?
          </li>
<li class="listitem">
            Should we avoid double storage but sometimes allocate ourselves on the
            heap?
          </li>
<li class="listitem">
            Should we make "backup copies", and how aggressively?
          </li>
<li class="listitem">
            Should we have an empty state? What should happen if we are visited or
            queried while empty?
          </li>
<li class="listitem">
            Should we throw exceptions?
          </li>
</ul></div>
<p>
        In the next section we'll discuss various options in detail, but to motivate
        our approach, we'd like to argue that an approach which <span class="emphasis"><em>requires
        as little bandwidth to explain to the programmer as possible</em></span> is
        a good one.
      </p>
<p>
        To that end, let's try to design a general <code class="computeroutput"><span class="identifier">variant</span></code>
        from the ground up by <span class="emphasis"><em>reducing the problem to a simpler one</em></span>.
      </p>
<p>
        The simpler problem is,
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            designing a <code class="computeroutput"><span class="identifier">variant</span></code> which
            is restricted to contain only value-types which are <span class="bold"><strong>nothrow
            move constructible</strong></span>.
          </li></ul></div>
<p>
        It turns out that this problem is really much simpler -- there is no longer
        any issue with the "throwing, type-changing assignment". We can
        always vacate the storage and then move the new value in, since the move
        won't throw. Compared to the general problem, this kind of variant is straightforward
        to implement optimally. Basically everything can be done by "copy and
        swap" and similar idioms -- there are no "surprises" here
        really.
      </p>
<p>
        Now,
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            how can we reduce general variant to this kind of variant?
          </li></ul></div>
<p>
        It turns out we can do it in a simple way using a little template:
      </p>
<pre class="programlisting"><span class="identifier">c</span><span class="special">++</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">using</span> <span class="identifier">wrap_if_throwing_move_t</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">conditional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_nothrow_move_constructible</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span>
                                                          <span class="identifier">T</span><span class="special">,</span>
                                                          <span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;;</span>
</pre>
<p>
        Now, for the general form of the variant, we apply <code class="computeroutput"><span class="identifier">wrap_if_throwing_move_t</span></code>
        to each value-type.
      </p>
<p>
        The point is that even if <code class="computeroutput"><span class="identifier">T</span></code>
        has a throwing move, <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        can always be moved without throwing, because it is just a pointer.
      </p>
<p>
        Some care must be taken -- throughout the <code class="computeroutput"><span class="identifier">variant</span></code>
        interface, it is important that <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        is transparently pierced for the user, not only for convenience, but for
        correctness -- the user should not be able to make the <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        empty.
      </p>
<p>
        But, with adequate care for such issues, you are now perfectly capable of
        going and writing your own <code class="computeroutput"><span class="identifier">strict_variant</span></code>,
        and you'll get more or less the same thing at least in regards to all the
        "controversial" parts of implementing a variant.
      </p>
<p>
        Possibly the most significant value-add of <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        is:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            It's never empty like <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>,
            but you can have a much simpler mental model of what it is doing under
            the hood, and it's easier to figure out exactly which operations on it
            can potentially throw what exceptions.
          </li></ul></div>
<p>
        For an extended comparison of this and several other possible implementation
        strategies, see the design page.
      </p>
<h4>
<a name="strict_variant.overview.abstract_and_motivation.h4"></a>
        <span><a name="strict_variant.overview.abstract_and_motivation.goals"></a></span><a class="link" href="abstract_and_motivation.html#strict_variant.overview.abstract_and_motivation.goals">Goals</a>
      </h4>
<p>
        The design goals of <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        are:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Provide a variant type which is strongly exception safe and never-empty.
          </li>
<li class="listitem">
            Make it as convenient and easy to use as <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>.
          </li>
<li class="listitem">
            Avoid the overhead of copies and dynamic allocations to the extent possible
            within these constraints.
          </li>
<li class="listitem">
            Favor an implementation which will be easy for the programmer to understand.
          </li>
<li class="listitem">
            Avoid "unexpected" and/or non-portable implicit conversions
            of fundamental types during variant assignment, to increase type-safety
            when using the variant.
          </li>
</ul></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../overview.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../overview.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="design.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
