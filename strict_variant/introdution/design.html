<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Design</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Strict Variant 0.0">
<link rel="up" href="../introdution.html" title="Introduction">
<link rel="prev" href="abstract_and_motivation.html" title="Abstract and Motivation">
<link rel="next" href="../tutorial.html" title="Tutorial">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="abstract_and_motivation.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../introdution.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="../tutorial.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="strict_variant.introdution.design"></a><a class="link" href="design.html" title="Design">Design</a>
</h3></div></div></div>
<p>
        In recent years, C++ developers have become very interested in heterogenous
        containers -- containers that can contain an value which might be of several
        different types.
      </p>
<p>
        One way to approach the problem is to use a <code class="computeroutput"><span class="keyword">union</span></code>
        type. Prior to C++11, a union could only contain POD types. Since C++11,
        this restriction was relaxed, but the compiler still does not generate useful
        special member functions. A union is ultimately a very low level construct
        -- usually, it's a building block one may use in creating a more user-friendly
        type, rather than a solution itself.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> introduced a very simple, batteries-included
        solution and became a very influential library. Besides providing a generic,
        type-safe, discriminated union, it also provided a concept of <span class="emphasis"><em>static
        visitor</em></span>. A static visitor is function object which the programmer
        creates in order to "visit" the variant type in a systematic fashion,
        rather than using a sequence of <code class="computeroutput"><span class="keyword">if</span>
        <span class="special">...</span> <span class="keyword">else</span></code>
        or similar .
      </p>
<p>
        The function object's implementation may use templates, and so take advantage
        of C++'s pattern matching abilities when visiting the variant type, which
        is very powerful and convenient. This is perhaps the closest thing in current
        versions of C++ to the pattern matching features found in languages like
        ML, Rust, and Haskell.
      </p>
<p>
        However, one of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>'s constraints is that it doesn't
        require C++11 -- its interface and design work in a way that accomodates
        C++ sans move semantics and <code class="computeroutput"><span class="keyword">noexcept</span></code>
        annotations, which gives up certain optimization opportunities. Some of these
        gains can be realized by using the most recent versions of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> when it enables C++11 features,
        but some cannot, as we will see.
      </p>
<h4>
<a name="strict_variant.introdution.design.h0"></a>
        <span><a name="strict_variant.introdution.design.never_empty_guarantee"></a></span><a class="link" href="design.html#strict_variant.introdution.design.never_empty_guarantee">Never-Empty
        Guarantee</a>
      </h4>
<p>
        The core issue in implementing a <code class="computeroutput"><span class="identifier">variant</span></code>
        is how to handle a <span class="emphasis"><em>throwing, type-changing assignment</em></span>
        <sup>[<a name="strict_variant.introdution.design.f0" href="#ftn.strict_variant.introdution.design.f0" class="footnote">1</a>]</sup>.
      </p>
<p>
        Fundamentally, there is a chicken-and-egg problem: When the variant is assigned
        to a value different from the currently contained type, we must first destroy
        the current value in order to vacate the storage, then we can construct the
        new value in that storage. Clearly, we can't construct the new value without
        destroying the old value first. But on the other hand, if constructing the
        new value fails by throwing an exception, we would like to retain the old
        value, so that we can have roll-back semantics and strong exception safety.
        Once it's destroyed, we can't exactly do that anymore. So somehow, neither
        of these steps should happen first.
      </p>
<p>
        There are a number of possible ways to resolve this issue.
      </p>
<h5>
<a name="strict_variant.introdution.design.h1"></a>
        <span><a name="strict_variant.introdution.design.double_storage_approach"></a></span><a class="link" href="design.html#strict_variant.introdution.design.double_storage_approach">Double-storage
        approach</a>
      </h5>
<p>
        One simple solution is to allocate double the storage for the variant. Then,
        the new object need not be allocated in the same memory as the old object,
        so it can always be constructed first and the issue is resolved. <sup>[<a name="strict_variant.introdution.design.f1" href="#ftn.strict_variant.introdution.design.f1" class="footnote">2</a>]</sup>
      </p>
<p>
        But in some applications, the overhead of double memory usage isn't tolerable.
      </p>
<h5>
<a name="strict_variant.introdution.design.h2"></a>
        <span><a name="strict_variant.introdution.design.boost_variant_approach"></a></span><a class="link" href="design.html#strict_variant.introdution.design.boost_variant_approach"><code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> approach</a>
      </h5>
<p>
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> resolves this tension as follows.
        First, it assumes that the contained object is copyable, and then, before
        any type-changing assignment, makes a backup copy of your object on the heap.
        Then the object in storage is destroyed and the new one is created. If construction
        fails, the variant holds onto the heap pointer, and subsequent accesses go
        via that pointer, until a new assignment takes place. <sup>[<a name="strict_variant.introdution.design.f2" href="#ftn.strict_variant.introdution.design.f2" class="footnote">3</a>]</sup>
      </p>
<p>
        In many scenarios, this is a great solution -- the storage overhead is at
        most the size of a pointer. However, if your object is expensive or impossible
        to copy, then this won't work so well for you.
      </p>
<h5>
<a name="strict_variant.introdution.design.h3"></a>
        <span><a name="strict_variant.introdution.design.std_variant_approach"></a></span><a class="link" href="design.html#strict_variant.introdution.design.std_variant_approach"><code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code>
        approach</a>
      </h5>
<p>
        After much discussion, the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code>
        of C++17 took the following approach: relax the "never-empty" guarantee
        to a "rarely-empty" guarantee, by introducing an empty state which
        occurs when construction of the new object fails. This empty state can be
        queried, and if a variant is visited which was made empty by an earlier exception,
        then a <code class="computeroutput"><span class="identifier">bad_visit</span></code> is thrown.
        This is the so-called "Kona Compromise". <sup>[<a name="strict_variant.introdution.design.f3" href="#ftn.strict_variant.introdution.design.f3" class="footnote">4</a>]</sup>
      </p>
<p>
        This solution has several obvious advantages -- we don't have to assume that
        the user type is copyable, and we don't have to make a backup copy at all,
        which is significantly more efficient in some cases. In terms of performance,
        we basically get ideal behavior, for assignments and for the storage space
        used by the variant.
      </p>
<p>
        However, it also complicates the interface to the <code class="computeroutput"><span class="identifier">variant</span></code>,
        as now the programmer needs to think about and sometimes query the empty
        state.
      </p>
<p>
        In many projects, the empty state isn't a meaningful concern and this solution
        works wonderfully.
      </p>
<p>
        Indeed, many other modern C++ variant types targetting C++11 and C++14 have
        followed suit and adopted the <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code>
        interface and behavior <sup>[<a name="strict_variant.introdution.design.f4" href="#ftn.strict_variant.introdution.design.f4" class="footnote">5</a>]</sup> <sup>[<a name="strict_variant.introdution.design.f5" href="#ftn.strict_variant.introdution.design.f5" class="footnote">6</a>]</sup>.
      </p>
<p>
        However, in some projects, when the exception caused by object is thrown,
        we want to recover and proceed with what we were doing. Depending on the
        lifetimes of the containers in the project, a variant with only a <span class="emphasis"><em>basic</em></span>
        exception safety guarantee may be very inconvenient, as now we may have to
        go find that variant and put it in a good state before attempting to proceed,
        or risk it throwing a new exception when we try to use it. In these projects,
        it would be much nicer if the exception only invalidates the object that
        threw it, and not also the surrounding container.
      </p>
<h5>
<a name="strict_variant.introdution.design.h4"></a>
        <span><a name="strict_variant.introdution.design.strict_variant_approach"></a></span><a class="link" href="design.html#strict_variant.introdution.design.strict_variant_approach"><code class="computeroutput"><span class="identifier">strict_variant</span></code> approach</a>
      </h5>
<p>
        Since most standard and boost containers provide strong-exception safety,
        it seems quite desirable to have at our disposal an efficient, modern C++
        variant type which also provides this guarantee. And indeed, there have been
        some standardization proposals like this <sup>[<a name="strict_variant.introdution.design.f6" href="#ftn.strict_variant.introdution.design.f6" class="footnote">7</a>]</sup> <sup>[<a name="strict_variant.introdution.design.f7" href="#ftn.strict_variant.introdution.design.f7" class="footnote">8</a>]</sup>.
      </p>
<p>
        <code class="computeroutput"><span class="identifier">strict_variant</span></code> achieves this
        by making a different implementation decision with a different trade-off.
        Instead of compromising on strong-exception safety, we compromise somewhat
        on the stack-based goal -- we simply say that any type that is not no-throw
        move-constructible needs to be allocated on the heap. In other words, only
        objects that are no-throw move-constructible are elligible for in situ storage
        in the variant, and objects with throwing moves must be on the heap. When
        using the <code class="computeroutput"><span class="identifier">easy_variant</span></code> template
        alias, this scenario is detected and handled transparently to the programmer,
        giving a general, easy-to-use, and performant variant.
      </p>
<p>
        From the user's point of view, this design results in a very familiar feel:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            The container is strongly exception safe, like the containers that you
            are used to
          </li>
<li class="listitem">
            It's easy to understand what is going on under the hood.
            <div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem">
                  Because every type is either nothrow-moveable itself or is put
                  in a nothrow-moveable wrapper, the chicken-and-egg problem is solved,
                  and assigning happens in a simple and intuitive way.
                </li>
<li class="listitem">
                  <span class="emphasis"><em>Move assignment</em></span> works by destroying the contained
                  object first, then moving the new value into storage, which never
                  fails.
                </li>
<li class="listitem">
                  <span class="emphasis"><em>Copy assignment</em></span> works via the "copy and
                  move" idiom, just as you might use in one of your classes
                  -- we simply make a copy on the stack, and if it succeeds, destroy
                  the contained value and move the new one into storage, which never
                  fails.
                </li>
</ul></div>
          </li>
<li class="listitem">
            There is no storage overhead -- the only memory used is the memory for
            the largest of the contained types, plus an indicator for the current
            type.
          </li>
<li class="listitem">
            Visitation is simple, just like it was for <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>.
            You don't have to worry about an empty state.
          </li>
<li class="listitem">
            <code class="computeroutput"><span class="identifier">strict_variant</span></code> doesn't
            actually come with any of its own exception types, and doesn't do any
            explicit <code class="computeroutput"><span class="keyword">try</span></code>, <code class="computeroutput"><span class="keyword">catch</span></code>, or <code class="computeroutput"><span class="keyword">throw</span></code>.
            You don't have to add new exception types to your mental checklist when
            you use it, and it is very easy to use in applications that are compiled
            with <code class="computeroutput"><span class="special">-</span><span class="identifier">fnoexceptions</span></code>
            and / or <code class="computeroutput"><span class="special">-</span><span class="identifier">fno</span><span class="special">-</span><span class="identifier">rtti</span></code>.
          </li>
</ul></div>
<p>
        Of course, this implementation pays a cost when we try to access one of the
        types with a throwing move, since it is on the heap. However, this also is
        somewhat consistent with the rest of the standard library -- since C++11,
        most programmers have learned that they should try hard to make their objects
        no-throw moveable if possible, since many standard library containers such
        as vector will be able to use a "fast path" in that case and be
        much more efficient.
      </p>
<p>
        While it's been well-established that throwing moves are sometimes hard to
        avoid and can't reasonably be banned from general-purpose containers, <sup>[<a name="strict_variant.introdution.design.f8" href="#ftn.strict_variant.introdution.design.f8" class="footnote">9</a>]</sup>, it seems that supporting them by putting them on the heap is
        a reasonable solution to the problem. If such objects are large and complex
        enough, it may be favorable to allocate them on the heap anyways.
      </p>
<h4>
<a name="strict_variant.introdution.design.h5"></a>
        <span><a name="strict_variant.introdution.design.easy_control_of_abstraction_pena"></a></span><a class="link" href="design.html#strict_variant.introdution.design.easy_control_of_abstraction_pena">Easy
        control of abstraction penalty</a>
      </h4>
<p>
        Another nice aspect of our design is that we make it easy for the programmer
        to <span class="emphasis"><em>control the overhead</em></span> that they pay to support the
        throwing move situation, to the degree that they want to.
      </p>
<h5>
<a name="strict_variant.introdution.design.h6"></a>
        <span><a name="strict_variant.introdution.design.strict_variant"></a></span><a class="link" href="design.html#strict_variant.introdution.design.strict_variant">strict_variant</a>
      </h5>
<p>
        The <span class="emphasis"><em>"real"</em></span> implementation of the variant type,
        <code class="computeroutput"><span class="identifier">strict_variant</span></code>, only fully
        supports types which are no-throw move constructible.
      </p>
<p>
        If it is constructed with a type that is not no-throw move constructible,
        then the variant cannot generate assignment operators -- a compiler error
        results.
      </p>
<p>
        In some projects, this is more desirable than a container which silently
        begins to make extra heap allocations. When a <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        cannot be assigned and needs to be, the programmer resolves the situation
        either by factoring out the throwing move, or putting the type in <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code> within the variant declaration.
        (Or using the <code class="computeroutput"><span class="identifier">emplace</span></code> member
        function, rather than assignment.)
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          Recall that <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_wrapper</span></code> is a component from
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>.
        </p>
<p>
          A <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
          represents a heap-allocated instance of <code class="computeroutput"><span class="identifier">T</span></code>.
        </p>
<p>
          In <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, this is used to allow declaring
          a variant which contains an incomplete type in a simple and ergonomic way
          -- there is special support code within <code class="computeroutput"><span class="identifier">variant</span></code>'s
          interface so that accessing an object in a recursive_wrapper can be done
          using the same syntax.
        </p>
</td></tr>
</table></div>
<p>
        Since our <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        is no-throw move constructible, even if <code class="computeroutput"><span class="identifier">T</span></code>
        is not, this effectively works around the issue, and the rest of your code
        using the variant can compile without changes after substituting <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> for
        <code class="computeroutput"><span class="identifier">T</span></code>.
      </p>
<p>
        When using <code class="computeroutput"><span class="identifier">strict_variant</span></code>,
        you thus control directly exactly what extra heap allocations are made in
        support of strong exception-safety, and it happens in a transparent way --
        you don't pay for anything you don't use.
      </p>
<p>
        If you can manage to make all your types no-throw move constructible, then
        you get <span class="emphasis"><em>ideal</em></span> variant performance -- no storage overhead,
        no extra copies or dynamic allocations, and no empty state to worry about.
      </p>
<h5>
<a name="strict_variant.introdution.design.h7"></a>
        <span><a name="strict_variant.introdution.design.easy_variant"></a></span><a class="link" href="design.html#strict_variant.introdution.design.easy_variant">easy_variant</a>
      </h5>
<p>
        We provide a template alias <code class="computeroutput"><span class="identifier">easy_variant</span></code>
        which takes care of these details if you don't care to be bothered by the
        compiler about a throwing move / dynamic allocation.
      </p>
<p>
        (Some programmers would prefer that the compiler not start making dynamic
        allocations without a warning, just because some <code class="computeroutput"><span class="keyword">noexcept</span></code>
        annotation was not deduced the way they expected. But programmer convenience
        is a good thing too.)
      </p>
<p>
        Specifically, any type that you put in the <code class="computeroutput"><span class="identifier">easy_variant</span></code>
        which has a throwing move will be wrapped in <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        implicitly.
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">strict_variant</span> <span class="special">{</span>
  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="special">...</span> <span class="identifier">Ts</span><span class="special">&gt;</span>
  <span class="keyword">using</span> <span class="identifier">easy_variant</span> <span class="special">=</span> <span class="identifier">variant</span><span class="special">&lt;</span><span class="identifier">wrap_if_thowing_move_t</span><span class="special">&lt;</span><span class="identifier">Ts</span><span class="special">&gt;...&gt;;</span>
<span class="special">}</span>
</pre>
<p>
        where <code class="computeroutput"><span class="identifier">wrap_if_throwing_move_t</span></code>
        is
      </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">strict_variant</span> <span class="special">{</span>
  <span class="keyword">struct</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">typename</span> <span class="special">=</span> <span class="identifier">mpl</span><span class="special">::</span><span class="identifier">enable_if_t</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_nothrow_destructible</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span> <span class="special">&amp;&amp;</span> <span class="special">!</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_reference</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">&gt;&gt;</span>
  <span class="keyword">struct</span> <span class="identifier">wrap_if_throwing_move</span> <span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">type</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">conditional</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_nothrow_move_constructible</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">,</span>
                                           <span class="identifier">T</span><span class="special">,</span>
                                           <span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;&gt;::</span><span class="identifier">type</span><span class="special">;</span>
  <span class="special">};</span>

  <span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
  <span class="keyword">using</span> <span class="identifier">wrap_if_throwing_move_t</span> <span class="special">=</span> <span class="keyword">typename</span> <span class="identifier">wrap_if_throwing_move</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">type</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
        So, <code class="computeroutput"><span class="identifier">easy_variant</span></code> means that
        if something starts throwing in the future, you won't have to go back and
        change your <code class="computeroutput"><span class="identifier">variant</span></code> declaration.
        But, if you can manage to make all the types involved no-throw move constructible,
        then you still don't pay anything for what you don't use.
      </p>
<h4>
<a name="strict_variant.introdution.design.h8"></a>
        <span><a name="strict_variant.introdution.design.implicit_conversions"></a></span><a class="link" href="design.html#strict_variant.introdution.design.implicit_conversions">Implicit
        Conversions</a>
      </h4>
<p>
        A secondary motivation of <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        is to reduce the errors caused by implicit conversions when using a <code class="computeroutput"><span class="identifier">variant</span></code>, and help achieve consistent cross-platform
        behavior.
      </p>
<p>
        For instance, some programmers consider it very undesirable that the following
        code compiles without a warning or error.
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="identifier">v</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
        When an assignment like this takes place, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>
        determines what type will be used via overload resolution. That is, a function
        object <code class="computeroutput"><span class="identifier">f</span></code> is created, which
        has overloads for <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code> and <code class="computeroutput"><span class="keyword">int</span></code>
        arguments. If overload resolution succeeds, then it determines which type
        will result inside of the variant.
      </p>
<p>
        A drawback of this is that it means that any C++ implicit conversions are
        permitted to take place when assigning a variant type.
      </p>
<p>
        Overload resolution is a core C++ language feature, and in 95% of cases it
        works very well and does the right thing.
      </p>
<p>
        However, in the 5% of cases where overload resolution does the wrong thing,
        it can be quite difficult to work around it. This includes the scenarios
        in which overload resolution is ambiguous, and those in an overload is selected
        which the user did not intend due to a subtle conversion.
      </p>
<p>
        Because integral types have so many permitted conversions, these problems
        are particularly obvious when you have a variant with several integral types.
      </p>
<p>
        This happens commonly when using variant types to interface with some scripting
        language for instance. The typical dynamically-typed scripting language will
        permit a variety of primitive values, so when binding to it, you may naturally
        end up with something like
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="keyword">float</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="special">...&gt;</span>
</pre>
<p>
        To make it easier to get good results when manipulating a variant like this,
        <code class="computeroutput"><span class="identifier">strict_variant</span></code> prevents many
        implicit conversions from occurring when two fundamental types are involved.
      </p>
<h5>
<a name="strict_variant.introdution.design.h9"></a>
        <span><a name="strict_variant.introdution.design.safe_conversions"></a></span><a class="link" href="design.html#strict_variant.introdution.design.safe_conversions">Safe
        Conversions</a>
      </h5>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Implicit conversions are not permitted between any two of the following
            classes:
            <div class="itemizedlist"><ul class="itemizedlist" type="circle">
<li class="listitem">
                  Integral types (<code class="computeroutput"><span class="keyword">short</span></code>,
                  <code class="computeroutput"><span class="keyword">int</span></code>, <code class="computeroutput"><span class="keyword">long</span></code>, <code class="computeroutput"><span class="keyword">long</span>
                  <span class="keyword">long</span></code>, and unsigned variations)
                </li>
<li class="listitem">
                  Floating point types (<code class="computeroutput"><span class="keyword">float</span></code>,
                  <code class="computeroutput"><span class="keyword">double</span></code>, <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">double</span></code>)
                </li>
<li class="listitem">
                  Character types (<code class="computeroutput"><span class="keyword">char</span></code>,
                  <code class="computeroutput"><span class="keyword">char16_t</span></code>, <code class="computeroutput"><span class="keyword">char32_t</span></code>, and unsigned variations)
                </li>
<li class="listitem">
                  Pointer types
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="keyword">bool</span></code>
                </li>
<li class="listitem">
                  <code class="computeroutput"><span class="keyword">wchar_t</span></code>
                </li>
</ul></div>
          </li>
<li class="listitem">
            If an integral or floating point conversion <span class="emphasis"><em>could</em></span>
            be narrowing on some conforming implementation of C++, then it is not
            safe. (So, <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
            cannot be converted to <code class="computeroutput"><span class="keyword">long</span></code>
            and <code class="computeroutput"><span class="keyword">long</span></code> cannot be converted
            to <code class="computeroutput"><span class="keyword">int</span></code>, even if you are
            on a 32-bit machine and they have the same size for you, because it could
            be narrowing on a 64-bit machine.)
          </li>
<li class="listitem">
            Signed can be promoted to unsigned, but the reverse is not allowed (since
            it is implementation-defined). This cannot be combined with widening.
          </li>
<li class="listitem">
            Conversions like <code class="computeroutput"><span class="keyword">char</span> <span class="special">*</span></code>
            to <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">char</span>
            <span class="special">*</span></code> are permitted, and standard
            conversions like array-to-pointer are permitted, but otherwise no pointer
            conversions are permitted.
          </li>
</ul></div>
<p>
        So for instance,
      </p>
<pre class="programlisting"><span class="identifier">strict_variant</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">,</span> <span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="identifier">v</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span>
</pre>
<p>
        is an error because <code class="computeroutput"><span class="keyword">bool</span></code> cannot
        be used to construct <code class="computeroutput"><span class="keyword">int</span></code> within
        the variant, and
      </p>
<pre class="programlisting"><span class="identifier">strict_variant</span><span class="special">&lt;</span><span class="keyword">long</span><span class="special">,</span> <span class="keyword">float</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="identifier">v</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span>
</pre>
<p>
        is not ambiguous -- <code class="computeroutput"><span class="keyword">int</span></code> to
        <code class="computeroutput"><span class="keyword">float</span></code> is not allowed by our
        rules, so it is eliminated from the overload resolution using SFINAE, and
        <code class="computeroutput"><span class="keyword">long</span></code> is unambiguously selected.
      </p>
<p>
        With <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, code like this is okay:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span><span class="special">&lt;</span><span class="keyword">const</span> <span class="keyword">void</span> <span class="special">*,</span> <span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span> <span class="identifier">str</span> <span class="special">=</span> <span class="string">"foo"</span><span class="special">;</span>
<span class="identifier">v</span> <span class="special">=</span> <span class="identifier">str</span><span class="special">;</span>
</pre>
<p>
        With <code class="computeroutput"><span class="identifier">strict_variant</span></code>, it isn't
        -- neither conversion <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">char</span> <span class="special">*</span></code> to
        <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">void</span>
        <span class="special">*</span></code> or to <code class="computeroutput"><span class="keyword">bool</span></code>
        is permitted to occur implicitly here.
      </p>
<p>
        In a more subtle example, this is not ambiguous:
      </p>
<pre class="programlisting"><span class="identifier">strict_variant</span><span class="special">&lt;</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span><span class="special">&gt;</span> <span class="identifier">v</span><span class="special">;</span>

<span class="identifier">v</span> <span class="special">=</span> <span class="number">100</span><span class="special">;</span>
<span class="identifier">v</span> <span class="special">=</span> <span class="number">100u</span><span class="special">;</span>
</pre>
<p>
        With <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, either of these is ambiguous,
        and you would have to use <code class="computeroutput"><span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">&gt;(</span><span class="number">100</span><span class="special">)</span></code> or something
        like <code class="computeroutput"><span class="identifier">v</span> <span class="special">=</span>
        <span class="number">100ULL</span></code>.
      </p>
<p>
        With <code class="computeroutput"><span class="identifier">strict_variant</span></code>, it's
        not allowed to combine widening with <code class="computeroutput"><span class="keyword">signed</span>
        <span class="special">-&gt;</span> <span class="keyword">unsigned</span></code>.
        So <code class="computeroutput"><span class="keyword">int</span></code> to <code class="computeroutput"><span class="keyword">unsigned</span>
        <span class="keyword">long</span> <span class="keyword">long</span></code>
        is eliminated. And <code class="computeroutput"><span class="keyword">unsigned</span> <span class="special">-&gt;</span> <span class="keyword">signed</span></code>
        can't happen implicitly at all, so <code class="computeroutput"><span class="keyword">unsigned</span>
        <span class="keyword">int</span></code> to <code class="computeroutput"><span class="keyword">long</span>
        <span class="keyword">long</span></code> is eliminated when we are assigning
        <code class="computeroutput"><span class="number">100u</span></code>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          <code class="computeroutput"><span class="identifier">strict_variant</span></code> conversion
          rules can only affect the result when the type contained in the variant
          is a fundamental type.
        </p>
<p>
          When the type contained is a user-defined type, all the normal conversions
          take effect -- if your type is constructible from <code class="computeroutput"><span class="keyword">unsigned</span>
          <span class="keyword">long</span> <span class="keyword">long</span></code>,
          we can't prevent the compiler from selecting it when assigning from an
          <code class="computeroutput"><span class="keyword">int</span></code> using SFINAE so far as
          I know. (And it's not clear that that would be desirable anyways.)
        </p>
</td></tr>
</table></div>
<p>
        The actual test is performed by a type trait, <code class="computeroutput"><span class="identifier">strict_variant</span><span class="special">::</span><span class="identifier">safely_constructible</span></code>,
        which refines <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">is_constructible</span></code>. You can make tests against
        that if you want to e.g. make static assertions that certain conversions
        are or aren't permitted.
      </p>
<h5>
<a name="strict_variant.introdution.design.h10"></a>
        <span><a name="strict_variant.introdution.design.rank_based_priority"></a></span><a class="link" href="design.html#strict_variant.introdution.design.rank_based_priority">Rank-based
        Priority</a>
      </h5>
<p>
        A second aspect of <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        is that we adopt a rank-based priority policy to resolve some overload ambiguities
        involving fundamental types.
      </p>
<p>
        Consider the following overloaded function:
      </p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">long</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">f</span><span class="special">(</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">);</span>

<span class="identifier">f</span><span class="special">(</span><span class="number">100</span><span class="special">);</span>
</pre>
<p>
        Under standard C++ rules, this function call is ambiguous: The argument
        <code class="computeroutput"><span class="identifier">f</span></code> is an <code class="computeroutput"><span class="keyword">int</span></code>,
        and both <code class="computeroutput"><span class="keyword">long</span></code> and <code class="computeroutput"><span class="keyword">long</span> <span class="keyword">long</span></code>
        can be obtained from <code class="computeroutput"><span class="keyword">int</span></code> by
        promotion. Since neither has a worse conversion, there is no best conversion.
      </p>
<p>
        When assigning to a <code class="computeroutput"><span class="identifier">variant</span></code>
        however, by far the most common situation is that the user wants to use the
        "smallest" type that will fit, since promotion represents a loss
        of information in some sense. (After the promotion, our knowledge of the
        bounds of the value are worse than they were before.) If later when they
        are visiting that value, they want to promote it to a larger type, that is
        easy to arrange.
      </p>
<p>
        Therefore, when an assignment is made to <code class="computeroutput"><span class="identifier">strict_variant</span></code>,
        if there are multiple integral types, it prioritizes them by rank. If a "safe
        conversion" is possible using types of a multiple ranks, only those
        of smallest rank are introduced into overload resolution, and the larger
        ones are not considered. In addition, <code class="computeroutput"><span class="keyword">signed</span></code>
        types are considered to have higher priority than their <code class="computeroutput"><span class="keyword">unsigned</span></code>
        counterparts.
      </p>
<p>
        These rules allow us to resolve any ties when converting from fundamental
        types to signed or unsigned integral types <code class="computeroutput"><span class="keyword">short</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span>
        <span class="keyword">long</span><span class="special">,</span> <span class="keyword">long</span> <span class="keyword">long</span></code>,
        signed or unsigned character types, and floating point types. (Note that
        the winner of these ties could still be ambiguous with a user-defined type
        which is also a member of the variant.)
      </p>
<h5>
<a name="strict_variant.introdution.design.h11"></a>
        <span><a name="strict_variant.introdution.design.emplace"></a></span><a class="link" href="design.html#strict_variant.introdution.design.emplace">Emplace</a>
      </h5>
<p>
        There is a second way to achieve a type-changing assignment: the <code class="computeroutput"><span class="identifier">emplace</span></code> member function.
      </p>
<pre class="programlisting"><span class="identifier">v</span><span class="special">.</span><span class="identifier">emplace</span><span class="special">&lt;</span><span class="keyword">long</span> <span class="keyword">long</span><span class="special">&gt;(</span><span class="number">100</span><span class="special">);</span>
<span class="identifier">v</span><span class="special">.</span><span class="identifier">emplace</span><span class="special">&lt;</span><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span><span class="special">&gt;(</span><span class="number">100</span><span class="special">);</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">emplace</span></code> takes a single template
        parameter, the type of the desired object to emplace. All other parameters
        are forwarded to its constructor. This can be used to put objects in the
        variant that are neither copyable nor moveable, so long as they are somehow
        no-throw constructible.
      </p>
<p>
        This can be used as an effective fallback when <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        refuses to generate assignment operators.
      </p>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.strict_variant.introdution.design.f0" href="#strict_variant.introdution.design.f0" class="para">1</a>] </sup>
          C.f. Axel Naumann "The Variant Saga: A happy ending?" <a href="https://isocpp.org/blog/2015/11/the-variant-saga-a-happy-ending" target="_top">https://isocpp.org/blog/2015/11/the-variant-saga-a-happy-ending</a>
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.strict_variant.introdution.design.f1" href="#strict_variant.introdution.design.f1" class="para">2</a>] </sup>
          C.f. Anthony Williams. Double-Storage Proposal. 2002.
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.strict_variant.introdution.design.f2" href="#strict_variant.introdution.design.f2" class="para">3</a>] </sup>
          C.f. Eric Friedman, Itay Maman. Online <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>
          documentation <a href="http://www.boost.org/doc/libs/1_61_0/doc/html/variant/design.html#variant.design.never-empty" target="_top">boost:doc/html/variant/design.html#variant.design.never-empty</a>
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.strict_variant.introdution.design.f3" href="#strict_variant.introdution.design.f3" class="para">4</a>] </sup>
          C.f. Axel Naumann. "Variant: a type-safe union (v6)" Proposal
          P0088r1 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r1.html" target="_top">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0088r1.html</a>
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.strict_variant.introdution.design.f4" href="#strict_variant.introdution.design.f4" class="para">5</a>] </sup>
          C.f. Agust&#237;n Berg&#233;. <code class="computeroutput"><span class="identifier">eggs</span><span class="special">::</span><span class="identifier">variant</span></code>
          online documentation. <a href="https://github.com/eggs-cpp/variant" target="_top">https://github.com/eggs-cpp/variant</a>
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.strict_variant.introdution.design.f5" href="#strict_variant.introdution.design.f5" class="para">6</a>] </sup>
          C.f. Artem Pavlenko. <code class="computeroutput"><span class="identifier">mapbox</span><span class="special">::</span><span class="identifier">variant</span></code>
          online documentation. <a href="https://github.com/mapbox/variant" target="_top">https://github.com/mapbox/variant</a>
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.strict_variant.introdution.design.f6" href="#strict_variant.introdution.design.f6" class="para">7</a>] </sup>
          C.f. David Sanke "Simply a Strong Variant". P0093R0 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0093r0.html" target="_top">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0093r0.html</a>
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.strict_variant.introdution.design.f7" href="#strict_variant.introdution.design.f7" class="para">8</a>] </sup>
          C.f. Anthony Williams "P0110R0: Implementing the strong guarantee
          for variant&lt;&gt; assignment" P0110R0 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0110r0.html" target="_top">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0110r0.html</a>
        </p></div>
<div class="footnote"><p><sup>[<a name="ftn.strict_variant.introdution.design.f8" href="#strict_variant.introdution.design.f8" class="para">9</a>] </sup>
          C.f. Ville Voutilainen Proposal P0129R0 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0129r0.html" target="_top">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0129r0.html</a>
        </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="abstract_and_motivation.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../introdution.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="../tutorial.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
