<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Future Directions</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Strict Variant 0.0">
<link rel="up" href="../remarks.html" title="Remarks">
<link rel="prev" href="benchmarks.html" title="Vistation Benchmarks">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="benchmarks.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../remarks.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="strict_variant.remarks.future_directions"></a><a class="link" href="future_directions.html" title="Future Directions">Future Directions</a>
</h3></div></div></div>
<h5>
<a name="strict_variant.remarks.future_directions.h0"></a>
        <span><a name="strict_variant.remarks.future_directions.constexpr_support"></a></span><a class="link" href="future_directions.html#strict_variant.remarks.future_directions.constexpr_support"><code class="computeroutput"><span class="keyword">constexpr</span></code> support</a>
      </h5>
<p>
        <code class="computeroutput"><span class="keyword">constexpr</span></code> support is somewhat
        harder to do well at C++11 standard compared to at C++14. And since <code class="computeroutput"><span class="keyword">constexpr</span></code> computations cannot make dynamic
        allocations, it's not consistent with <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        which is an essential component of <code class="computeroutput"><span class="identifier">easy_variant</span></code>.
        Any <code class="computeroutput"><span class="keyword">constexpr</span></code> usage would be
        somewhat orthogonal to the bulk of the development work so far.
      </p>
<p>
        It could be added in the future, but for now we simply use placement-new
        in our storage and there is no <code class="computeroutput"><span class="keyword">constexpr</span></code>
        support. We could use a more sophisticated storage object, like the recursive
        union used in <code class="computeroutput"><span class="identifier">eggs</span><span class="special">::</span><span class="identifier">variant</span></code>, without changing the existing
        code much. But again, at C++11 standard, it's much harder to do something
        useful within a visitor than it is at C++14, so it's not all that attractive.
      </p>
<p>
        If you need this, you might want to take a good look at <a href="http://eggs-cpp.github.io/variant/index.html" target="_top"><code class="computeroutput"><span class="identifier">eggs</span><span class="special">::</span><span class="identifier">variant</span></code></a>.
      </p>
<h5>
<a name="strict_variant.remarks.future_directions.h1"></a>
        <span><a name="strict_variant.remarks.future_directions.allocator_support"></a></span><a class="link" href="future_directions.html#strict_variant.remarks.future_directions.allocator_support"><code class="computeroutput"><span class="identifier">allocator</span></code> support</a>
      </h5>
<p>
        Since <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code> makes
        dynamic allocations on behalf of the variant, a quite natural refinement
        would be to allow custom allocators to be used with the wrapper.
      </p>
<p>
        Most likely, the allocator should become a template parameter and a member
        of the <code class="computeroutput"><span class="identifier">strict_variant</span></code> itself,
        which then passes it on to any <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        that are constructed. But execution of this plan is left to future work.
      </p>
<h5>
<a name="strict_variant.remarks.future_directions.h2"></a>
        <span><a name="strict_variant.remarks.future_directions.extract_heap_objects"></a></span><a class="link" href="future_directions.html#strict_variant.remarks.future_directions.extract_heap_objects">Extract
        heap objects</a>
      </h5>
<p>
        One way to mitigate the costs of using <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        in the variant would be if it were possible to "take ownership"
        of the dynamic allocation from the variant. The idea would be, once the contained
        type has been determined to be <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>,
        we could imagine a function which consumes the variant and yields <code class="computeroutput"><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>,
        taking ownership of the pointer that is in storage.
      </p>
<p>
        This is also left to future work.
      </p>
<h5>
<a name="strict_variant.remarks.future_directions.h3"></a>
        <span><a name="strict_variant.remarks.future_directions.improve_noexcept_annotations_of_"></a></span><a class="link" href="future_directions.html#strict_variant.remarks.future_directions.improve_noexcept_annotations_of_">Improve
        <code class="computeroutput"><span class="keyword">noexcept</span></code> annotations of <code class="computeroutput"><span class="identifier">variant</span></code> when using <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>?</a>
      </h5>
<p>
        One of the basic design ideas here is to use <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        when a type has a throwing move.
      </p>
<p>
        However, this has the potential to reduce the quality of our <code class="computeroutput"><span class="keyword">noexcept</span></code> annotations in certain situations.
      </p>
<p>
        The reason is that, <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        is supposed to work also when the type is incomplete -- in that case the
        traits that determine whether special member functions of the variant throw,
        basically have to assume that they might, since we can't check the actual
        type.
      </p>
<p>
        In cases when the type <span class="bold"><strong>is</strong></span> complete, we could
        introduce a different wrapper, say, <code class="computeroutput"><span class="identifier">heap_wrapper</span></code>
        or something, which would be the same, but we would be able to interrogate
        the type to determine situations in which it throws.
      </p>
<p>
        Now, usually you would only use <code class="computeroutput"><span class="identifier">heap_wrapper</span></code>
        when the type has a throwing move, and in that case, it likely also has a
        throwing copy. So not much is likely to be gained by <code class="computeroutput"><span class="identifier">heap_wrapper</span></code>
        here.
      </p>
<p>
        It would be nice if, when <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        is used with a type which is incomplete, but doesn't actually throw, we can
        actually deduce that fact. But as far as I know this isn't feasible -- the
        <code class="computeroutput"><span class="keyword">noexcept</span></code> annotations on the
        <code class="computeroutput"><span class="identifier">variant</span></code> special member functions
        must be complete at the point of instantiation of the variant. So we have
        to assume the worst when the user uses <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>,
        so far as I know.
      </p>
<h5>
<a name="strict_variant.remarks.future_directions.h4"></a>
        <span><a name="strict_variant.remarks.future_directions.add_an_operator_t_overload"></a></span><a class="link" href="future_directions.html#strict_variant.remarks.future_directions.add_an_operator_t_overload">Add
        an <code class="computeroutput"><span class="keyword">operator</span> <span class="special">=</span>
        <span class="special">(</span><span class="identifier">T</span> <span class="special">&amp;&amp;)</span></code> overload?</a>
      </h5>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          This was done, and the documentation and future work needs to be updated.
          TODO
        </p></td></tr>
</table></div>
<p>
        Currently, the only conversions from non-variant types to variants happen
        in the forwarding-reference constructor. A statement:
      </p>
<pre class="programlisting"><span class="identifier">var_t</span> <span class="identifier">v</span><span class="special">;</span>
<span class="identifier">v</span> <span class="special">=</span> <span class="number">5</span><span class="special">;</span>
</pre>
<p>
        actually compiles to something like this:
      </p>
<pre class="programlisting"><span class="identifier">var_t</span> <span class="identifier">v</span><span class="special">;</span>
<span class="identifier">v</span> <span class="special">=</span> <span class="identifier">var_t</span><span class="special">{</span><span class="number">5</span><span class="special">};</span>
</pre>
<p>
        This is why assignment cannot work if <span class="bold"><strong>any</strong></span>
        of the types in <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        has a throwing move. Even if the value <code class="computeroutput"><span class="number">5</span></code>
        as above does not.
      </p>
<p>
        Currently, the only assignment operators are the usual special member functions.
      </p>
<p>
        We could consider adding an <code class="computeroutput"><span class="keyword">operator</span>
        <span class="special">=</span> <span class="special">(</span><span class="identifier">T</span><span class="special">&amp;&amp;)</span></code>
        overload so that syntax like
      </p>
<pre class="programlisting"><span class="identifier">v</span> <span class="special">=</span> <span class="number">5</span><span class="special">;</span>
</pre>
<p>
        is legal, even if <code class="computeroutput"><span class="identifier">var_t</span></code> contains
        some types with throwing moves.
      </p>
<p>
        However,
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            It would involve significant code duplication -- we would also have to
            duplicate the "generalizing constructors" which promote a variant
            to a variant over more types.
          </li>
<li class="listitem">
            There are already effective workarounds -- use <code class="computeroutput"><span class="identifier">emplace</span></code>,
            the <code class="computeroutput"><span class="identifier">emplace</span> <span class="identifier">ctor</span></code>,
            or use <code class="computeroutput"><span class="identifier">easy_variant</span></code>.
          </li>
</ol></div>
<p>
        I haven't been able to convince myself that adding this is actually a good
        idea, but I might be open to it in the future.
      </p>
<p>
        After most recent refactors, the code duplication here would be much less,
        and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> does this, so it might be a good
        idea to do it also.
      </p>
<h5>
<a name="strict_variant.remarks.future_directions.h5"></a>
        <span><a name="strict_variant.remarks.future_directions.support_references_using_std_ref"></a></span><a class="link" href="future_directions.html#strict_variant.remarks.future_directions.support_references_using_std_ref">Support
        references using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">reference_wrapper</span></code>?</a>
      </h5>
<p>
        The <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code> does this, but it doesn't seem
        all that useful, and would introduce more complex rules for safety.
      </p>
<h5>
<a name="strict_variant.remarks.future_directions.h6"></a>
        <span><a name="strict_variant.remarks.future_directions.support_arrays_implicitly_using_"></a></span><a class="link" href="future_directions.html#strict_variant.remarks.future_directions.support_arrays_implicitly_using_">Support
        arrays implicitly using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">array</span></code>?</a>
      </h5>
<p>
        It seems simpler to just explicitly forbid arrays, but I didn't do this yet
        either.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="benchmarks.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../remarks.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a>
</div>
</body>
</html>
