<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Implementation Notes</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Strict Variant 0.0">
<link rel="up" href="../remarks.html" title="Remarks">
<link rel="prev" href="compiler_compatibility.html" title="Compiler Compatibility">
<link rel="next" href="comparison_and_performance_chara.html" title="Comparison and Performance Characteristics">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="compiler_compatibility.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../remarks.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="comparison_and_performance_chara.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="strict_variant.remarks.implementation_notes"></a><a class="link" href="implementation_notes.html" title="Implementation Notes">Implementation
      Notes</a>
</h3></div></div></div>
<p>
        As mentioned in the <a class="link" href="../intro/design.html" title="Design">design notes</a>,
        the implementation details of the actual <code class="computeroutput"><span class="identifier">variant</span></code>
        class end up being relatively simple, and the wrapper abstraction ends up
        doing much of the work related to exception safety.
      </p>
<p>
        The main subtlety involved in the overall implementation actually has to
        do with the <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>.
      </p>
<p>
        If you'll recall, <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        represents a heap-allocated instance of <code class="computeroutput"><span class="identifier">T</span></code>.
        In the design section, we pointed out that a <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        could be moved by simply moving a pointer.
      </p>
<p>
        However, those who are intimately familiar with implementation details of
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> may recall that that is not actually
        how <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_wrapper</span></code> works.
      </p>
<p>
        In <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, when a <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        is move-constructed, what happens is a new dynamic allocation is made, and
        <code class="computeroutput"><span class="identifier">T</span></code> is move-constructed there.
      </p>
<p>
        We'll call that the "value-move", in contrast with the "pointer-move".
      </p>
<p>
        Clearly, the pointer-move plays a crucial role in <code class="computeroutput"><span class="identifier">strict_variant</span></code>,
        since the value-move is throwing, while the pointer-move isn't.
      </p>
<p>
        But, we can't always use the pointer-move.
      </p>
<p>
        To see why, consider that the point of the whole exercise is to create a
        never-empty variant. What happens if variant <code class="computeroutput"><span class="identifier">x</span></code>
        is moved-assigned into variant <code class="computeroutput"><span class="identifier">y</span></code>?
        If <code class="computeroutput"><span class="identifier">x</span></code> contains a <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code> and this is pointer-moved
        into <code class="computeroutput"><span class="identifier">y</span></code>, then <code class="computeroutput"><span class="identifier">x</span></code> is left holding nothing. It's effectively
        in an empty state, and since visitation implicitly pierces the <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>, the result would be
        UB if you attempt to visit <code class="computeroutput"><span class="identifier">x</span></code>
        after the move. Nevermind that "it's not empty, it merely contains an
        empty container" -- that's the sort of explanation that only a compiler
        would be satisfied with.
      </p>
<p>
        (Granted, in some applications, no one plans to visit a variant that has
        been moved from, and if they could avoid a dynamic allocation, they would
        prefer the pointer-move even if the variant gets left in a precarious state.
        We might implement some sort of configuration option to allow for this optimization,
        but doesn't exist now and I don't think it should be the default.)
      </p>
<p>
        With this in mind, how should <code class="computeroutput"><span class="identifier">strict_variant</span><span class="special">::</span><span class="identifier">recursive_wrapper</span></code>'s
        move ctor actually be implemented? Should we use tag-dispatch to differentiate
        the two options?
      </p>
<p>
        The strategy that we've adopted is, <code class="computeroutput"><span class="identifier">strict_variant</span><span class="special">::</span><span class="identifier">recursive_wrapper</span></code>'s
        move ctor is the pointer-move. But in most cases, when visiting a variant,
        even for purposes of copy or move construction of another variant, we call
        a function <code class="computeroutput"><span class="identifier">detail</span><span class="special">::</span><span class="identifier">pierce_recursive_wrapper</span></code> which ensures
        that we pierce the wrapper and move the value rather than the wrapper. Essentially,
        the only time that we want to visit a variant and not pierce the wrapper,
        is when calling the destructor.
      </p>
<p>
        (Obviously, when constructing the value that gets moved into <span class="bold"><strong>our</strong></span>
        storage though, we have to use exactly the type that was specified in the
        template parameters. This just won't always be the same as what the visited
        value is.)
      </p>
<p>
        This ensures correctness also when we are using the "generalizing"
        ctors of <code class="computeroutput"><span class="identifier">variant</span></code>.
      </p>
<p>
        See the <code class="computeroutput"><span class="identifier">move_constructor</span></code>
        and <code class="computeroutput"><span class="identifier">move_assigner</span></code> visitors
        in <code class="computeroutput"><span class="identifier">variant</span><span class="special">.</span><span class="identifier">hpp</span></code> for complete examples.
      </p>
<h4>
<a name="strict_variant.remarks.implementation_notes.h0"></a>
        <span><a name="strict_variant.remarks.implementation_notes.questions_and_answers"></a></span><a class="link" href="implementation_notes.html#strict_variant.remarks.implementation_notes.questions_and_answers">Questions
        and Answers</a>
      </h4>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Q</span></dt>
<dd><p>
              Is <code class="computeroutput"><span class="identifier">strict_variant</span></code> nothrow
              destructible?
            </p></dd>
<dt><span class="term">A</span></dt>
<dd><p>
              Yes. Each contained item must be, and the <code class="computeroutput"><span class="identifier">variant</span></code>
              is also.
            </p></dd>
</dl>
</div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Q</span></dt>
<dd><p>
              Is <code class="computeroutput"><span class="identifier">strict_variant</span></code> nothrow
              copyable?
            </p></dd>
<dt><span class="term">A</span></dt>
<dd><p>
              If each contained type is nothrow copyable, then <code class="computeroutput"><span class="identifier">strict_variant</span></code>
              is also. Otherwise, no. (If some types are not copyable, then <code class="computeroutput"><span class="identifier">strict_variant</span></code> isn't copyable at
              all.)
            </p></dd>
</dl>
</div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Q</span></dt>
<dd><p>
              Is <code class="computeroutput"><span class="identifier">strict_variant</span></code> nothrow
              moveable? Is <code class="computeroutput"><span class="identifier">easy_variant</span></code>?
            </p></dd>
<dt><span class="term">A</span></dt>
<dd><p>
              If each contained type is nothrow moveable, then <code class="computeroutput"><span class="identifier">strict_variant</span></code>
              is also. Since <code class="computeroutput"><span class="identifier">easy_variant</span></code>
              puts each type with a throwing move inside a <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
              which is nothrow moveable, <code class="computeroutput"><span class="identifier">easy_variant</span></code>
              is always nothrow moveable.
            </p></dd>
<dt><span class="term">A2</span></dt>
<dd>
<p>
              <span class="bold"><strong>WRONG</strong></span>.
            </p>
<p>
              Even though <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code> is nothrow moveable, that refers
              to the pointer-move, not the value-move. And value-move is what <code class="computeroutput"><span class="identifier">strict_variant</span></code> must use in its move
              constructor, see above. value-move is <span class="emphasis"><em>always</em></span> potentially
              throwing no matter what <code class="computeroutput"><span class="identifier">T</span></code>
              is, if only because of the dynamic allocation. The pointer-move is
              only okay to use when moving the temporary into storage.
            </p>
<p>
              <code class="computeroutput"><span class="identifier">strict_variant</span></code> is nothrow
              moveable as long as all the constituent types are, and as long as none
              of them are <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>. Otherwise, its move constructor
              is potentially throwing.
            </p>
</dd>
</dl>
</div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Q</span></dt>
<dd>
<p>
              This sucks! I am working hard to make my types nothrow moveable so
              I can be on the fast-track for <code class="computeroutput"><span class="identifier">strict_variant</span></code>,
              but then <code class="computeroutput"><span class="identifier">strict_variant</span></code>
              turns around and gives me a throwing move when I don't succeed -- even
              when I use <code class="computeroutput"><span class="identifier">easy_variant</span></code>
              like instructed!
            </p>
<p>
              This means that actually, in <a class="link" href="../tutorial/basic.html" title="Basic Usage">that
              code from the tutorial</a>, where we represent an XML node using
              <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>,
              we're actually on the slow track in that <code class="computeroutput"><span class="identifier">vector</span></code>,
              aren't we? So we'll implicitly get tons of copies of child xml nodes
              when parsing an xml tree and the vector has to resize, won't we?
            </p>
</dd>
<dt><span class="term">A2</span></dt>
<dd>
<p>
              Yes. I agree that this is unfortunate.
            </p>
<p>
              But, all I can say is that the implementation started with a pretty
              simple design idea, and I feel I was driven inexorably to this conclusion.
            </p>
<p>
              Somehow, the whole point of <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
              is to provide some syntactic sugar for the user. When it is really
              necessary or makes more sense for the something to be on the heap,
              but we don't want the user to have to think about that fact, <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code> is a good solution,
              because it gets it on the heap and gets transparently pierced by the
              <code class="computeroutput"><span class="identifier">variant</span></code> interface.
            </p>
<p>
              But if the <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
              has an empty state, which the user can easily get it into, this means
              that the user can transparently get UB, which is not a good thing.
            </p>
<p>
              If it is important to you that you wrap up a type with a throwing move
              in a way that doesn't give <code class="computeroutput"><span class="identifier">strict_variant</span></code>
              a throwing move, then what I recommend is that instead of using <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>,
              you use <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>.
            </p>
<p>
              Then when assigning, use <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">make_unique</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>, and when visiting, you get <code class="computeroutput"><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
              instead of <code class="computeroutput"><span class="identifier">T</span></code>, and you
              just <code class="computeroutput"><span class="special">*</span></code> it yourself, or
              do whatever handling you want for the null state. That seems more sound
              than the <code class="computeroutput"><span class="identifier">variant</span></code> itself
              <code class="computeroutput"><span class="special">*</span></code>'ing it for you when
              it could legitimately be null.
            </p>
<p>
              In this case, the variant will be nothrow moveable, because it will
              be using the pointer-move effectively.
            </p>
<p>
              The main drawback at that point is that, <code class="computeroutput"><span class="identifier">unique_ptr</span></code>
              is not copyable, so your <code class="computeroutput"><span class="identifier">strict_variant</span></code>
              won't be copyable. But it's pretty simple to roll your own quick <code class="computeroutput"><span class="identifier">unique_ptr</span></code> that rectifies that. Who
              knows, we might even do that for you in the next release...
            </p>
<p>
              Hopefully, this at least convinces you that <code class="computeroutput"><span class="identifier">strict_variant</span></code>
              is a flexible and useful low-level component, and that you can easily
              configure it like this to get the semantics that you need without introducing
              unnecessary overhead.
            </p>
</dd>
</dl>
</div>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">Q</span></dt>
<dd><p>
              When is <code class="computeroutput"><span class="identifier">strict_variant</span></code>
              nothrow assignable? <code class="computeroutput"><span class="identifier">easy_variant</span></code>?
            </p></dd>
<dt><span class="term">A</span></dt>
<dd>
<p>
              <code class="computeroutput"><span class="identifier">strict_variant</span></code> is copy
              assignable when all of its types are assignable, copy constructible,
              and nothrow move constructible. It is <code class="computeroutput"><span class="keyword">noexcept</span></code>
              copy assignable if each type's copy assignment and copy construction
              is <code class="computeroutput"><span class="keyword">noexcept</span></code>. <code class="computeroutput"><span class="identifier">easy_variant</span></code> is assignable if each
              type is copy constructible and assignable. Since copying a <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code> involves a dynamic
              allocation, <code class="computeroutput"><span class="identifier">easy_variant</span></code>'s
              copy assignment can throw if <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
              gets involved.
            </p>
<p>
              <code class="computeroutput"><span class="identifier">strict_variant</span></code> is move
              assignable when all of its types are move assignable and nothrow move
              constructible. It is <code class="computeroutput"><span class="keyword">noexcept</span></code>
              move assignable if each type's move assignment is <code class="computeroutput"><span class="keyword">noexcept</span></code>,
              AND if none is <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>.
              (Similar to when <code class="computeroutput"><span class="identifier">strict_variant</span></code>
              has a throwing move.) Because, we have to use the value-move first,
              and can only use the pointer-move to move into storage.
            </p>
<p>
              <code class="computeroutput"><span class="identifier">easy_variant</span></code> is move
              assignable as long as every template parameter is move assignable and
              move constructible. It is nothrow move assignable as long as all of
              the types are nothrow move assignable and nothrow move constructible
              -- none of them should actually end up in a <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>.
            </p>
</dd>
</dl>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="compiler_compatibility.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../remarks.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="comparison_and_performance_chara.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
