<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Performance Characteristics</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Strict Variant 0.0">
<link rel="up" href="../discussion.html" title="Remarks">
<link rel="prev" href="../discussion.html" title="Remarks">
<link rel="next" href="vistation_benchmarks.html" title="Vistation Benchmarks">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../discussion.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../discussion.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="vistation_benchmarks.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="strict_variant.discussion.performance_characteristics"></a><a class="link" href="performance_characteristics.html" title="Performance Characteristics">Performance
      Characteristics</a>
</h3></div></div></div>
<h4>
<a name="strict_variant.discussion.performance_characteristics.h0"></a>
        <span><a name="strict_variant.discussion.performance_characteristics.assignment"></a></span><a class="link" href="performance_characteristics.html#strict_variant.discussion.performance_characteristics.assignment">Assignment</a>
      </h4>
<p>
        The main point of variation among variant types is usually how they handle
        the never-empty guarantee. (Beyond that, they often vary significantly in
        how they actually implement the storage, especially if they seek <code class="computeroutput"><span class="keyword">constexpr</span></code> support.)
      </p>
<p>
        In <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, the strategy is to make a heap-allocated
        backup copy of the value, and then destroy the original and attempt to allocate
        the new value in the in situ storage. If that operation throws, then the
        heap-allocated copy still exists, and subsequent uses point to that. Any
        later type-changing assignments will try to take place in situ, and the heap-allocated
        backup will remain until one of those succeeds.
      </p>
<p>
        This provides the most comprehensive support, but it incurs an extra copy
        and an extra dynamic allocation for each assignment. There's also some space
        overhead for the pointer.
      </p>
<p>
        In the C++17 <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code>, the strategy is to relax the never-empty
        guarantee to a "rarely empty" guarantee, by introducing an empty
        state which occurs when construction fails. This greatly simplifies assignment
        and makes that more efficient, but it may complicate visitation, depending
        on how concerned you are about the empty state. In essence we are sacrificing
        strong exception safety for only basic exception safety, in a quest for performance.
      </p>
<p>
        In <code class="computeroutput"><span class="identifier">strict_variant</span></code>, the focus
        is on a less general case. We basically "favor" the nothrow move-constructible
        members, which enjoy optimal performance like they would in <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code>.
        We accomodates all members with throwing move by putting them on the heap
        -- then the pointer can be moved into storage without failure.
      </p>
<p>
        In comparison with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>,
        this results in no extra calls to copy constructors when we make an assignment.
        It also will impact speed of visitation, in the sense that you must dereference
        an extra pointer to find the object -- <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>
        always tries to get the object in situ, and only puts it on the heap if an
        exception is thrown. However, if exceptions are thrown regularly, then you
        would already have had to tolerate this overhead with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>.
        An advantage, though, is that operations on <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        are relatively easy to reason about, as there are no dynamic allocations
        taking place that you don't explicitly opt in to. And besides, for the use
        cases like those for which <code class="computeroutput"><span class="identifier">strict_variant</span></code>
        was originally designed and for which the "no unsafe conversions"
        property is most relevant, the types will all likely be no-throw move constructible
        anyways.
      </p>
<p>
        Regardless, at least when your types are in fact no-throw move constructible,
        we enjoy essentially the same interface as <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>
        updated to modern C++, without the extra copies or dynamic allocations that
        were required prior to C++11. And also in that case, we enjoy the same performance
        as <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">variant</span></code> without the added complexity of
        an empty state.
      </p>
<h4>
<a name="strict_variant.discussion.performance_characteristics.h1"></a>
        <span><a name="strict_variant.discussion.performance_characteristics.visitation"></a></span><a class="link" href="performance_characteristics.html#strict_variant.discussion.performance_characteristics.visitation">Visitation</a>
      </h4>
<p>
        The other major point of variation among variant templates is the speed of
        visitation.
      </p>
<p>
        In <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, at least the early implementations
        used <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span></code>, and were limited to twenty or so types.
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> works even prior to the variadic
        templates feature. Doing without variadic templates makes the header pretty
        complicated and hurts the compile times, but its very helpful to speed of
        visitation, which can be done using an explicit <code class="computeroutput"><span class="keyword">switch</span></code>
        statement.
      </p>
<p>
        In a variadic template-based implementation, switch statements cannot be
        used, because there is no pack-expansion analogue for switch statements.
        The most common strategy that I saw is to declare an array of function pointers,
        and fill it with a series of instantiations of a template function. Each
        pointer corresponds to an one of the input types. Then this array is indexed
        and the appropriate function pointer is called, passing along the visitor,
        the variant storage, etc. The array thus forms a little manual jump table
        of sorts.
      </p>
<p>
        This implementation is pretty straightforward, but it has the drawback that
        the function pointers cannot always be inlined by the compiler, and so for
        relatively small numbers of elements, it can be outperformed by other strategies.
      </p>
<p>
        In a second strategy, a binary tree is formed which holds at each leaf one
        of the input types. We then search the binary tree using the "which"
        value which would have been the index to the jump table. When we arrive at
        the leaf, we know the runtime-type of the value, and can invoke the visitor
        appropriately. This implementation involves no function pointers, so the
        calls can always be inlined -- but it may involve several branches. However,
        these branches may benefit from branch prediction, and in practice, its quite
        common to have variants with only a handful of types. Particularly when there
        is one type which is the "most popular", branch prediction can
        significantly speed up the visitation well beyond what you will see in benchmarks
        with random data, which are already quite favorable to the "binary"
        search strategy for small numbers of types. This is the strategy currently
        used by <code class="computeroutput"><span class="identifier">strict_variant</span></code>.
      </p>
<p>
        A third strategy, naive tail recursion, is used by <code class="computeroutput"><span class="identifier">mapbox</span><span class="special">::</span><span class="identifier">variant</span></code>.
        Surprisingly (for me), this is the best performing strategy, for both <code class="computeroutput"><span class="identifier">gcc</span></code> and <code class="computeroutput"><span class="identifier">clang</span></code>
        and all regimes, according to most recent benchmark investigations.
      </p>
<p>
        See the next section for benchmark data.
      </p>
<h4>
<a name="strict_variant.discussion.performance_characteristics.h2"></a>
        <span><a name="strict_variant.discussion.performance_characteristics.compile_times"></a></span><a class="link" href="performance_characteristics.html#strict_variant.discussion.performance_characteristics.compile_times">Compile-Times</a>
      </h4>
<p>
        I did not attempt to benchmark the compile-time performance, but I expect
        that the differences would be negligible, especially in comparison to other
        common libraries which are known to have heavy compile times.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../discussion.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../discussion.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="vistation_benchmarks.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
