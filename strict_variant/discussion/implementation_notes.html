<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Implementation Notes</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Strict Variant 0.0">
<link rel="up" href="../discussion.html" title="Remarks">
<link rel="prev" href="../discussion.html" title="Remarks">
<link rel="next" href="comparison_and_performance_chara.html" title="Comparison and Performance Characteristics">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../discussion.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../discussion.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="comparison_and_performance_chara.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="strict_variant.discussion.implementation_notes"></a><a class="link" href="implementation_notes.html" title="Implementation Notes">Implementation
      Notes</a>
</h3></div></div></div>
<p>
        The main subtlety involved in correctly implementing the design has to do
        with the <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>.
      </p>
<p>
        If you'll recall, <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        represents a heap-allocated instance of <code class="computeroutput"><span class="identifier">T</span></code>.
        In the design section, we pointed out that a <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        could be moved by simply moving a pointer.
      </p>
<p>
        However, those who are intimately familiar with implementation details of
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code> may recall that that is not actually
        how <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">recursive_wrapper</span></code> works.
      </p>
<p>
        In <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">variant</span></code>, when a <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        is move-constructed, what happens is a new dynamic allocation is made, and
        <code class="computeroutput"><span class="identifier">T</span></code> is move-constructed there.
      </p>
<p>
        We'll call that the "value-move", in contrast with the "pointer-move".
      </p>
<p>
        Clearly, the pointer-move plays a crucial role in <code class="computeroutput"><span class="identifier">strict_variant</span></code>,
        since the value-move is throwing, while the pointer-move isn't.
      </p>
<p>
        But, we can't always use the pointer-move.
      </p>
<p>
        To see why, consider that the point of the whole exercise is to create a
        never-empty variant. What happens if variant <code class="computeroutput"><span class="identifier">x</span></code>
        is moved-assigned into variant <code class="computeroutput"><span class="identifier">y</span></code>?
        If <code class="computeroutput"><span class="identifier">x</span></code> contains a <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code> and this is pointer-moved
        into <code class="computeroutput"><span class="identifier">y</span></code>, then <code class="computeroutput"><span class="identifier">x</span></code> is left holding nothing. It's effectively
        in an empty state, and since visitation implicitly pierces the <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>, the result would be
        UB if you attempt to visit <code class="computeroutput"><span class="identifier">x</span></code>
        after the move. Nevermind that "it's not empty, it merely contains an
        empty container" -- that's the sort of explanation that only a compiler
        would be satisfied with.
      </p>
<p>
        (Granted, in some applications, no one plans to visit a variant that has
        been moved from, and if they could avoid a dynamic allocation, they would
        prefer that it gets left in some illegal/empty state. We might implement
        some sort of configuration option to allow for this optimization, but doesn't
        exist now and it wouldn't the default.)
      </p>
<p>
        With this in mind, how should <code class="computeroutput"><span class="identifier">strict_variant</span><span class="special">::</span><span class="identifier">recursive_wrapper</span></code>'s
        move ctor actually be implemented? Should we use tag-dispatch to differentiate
        the two options?
      </p>
<p>
        The strategy that we've adopted is, <code class="computeroutput"><span class="identifier">strict_variant</span><span class="special">::</span><span class="identifier">recursive_wrapper</span></code>'s
        move ctor is the pointer move. But in most cases, when visiting a variant,
        even for purposes of copy or move construction of another variant, we call
        a function <code class="computeroutput"><span class="identifier">detail</span><span class="special">::</span><span class="identifier">pierce_recursive_wrapper</span></code> which ensures
        that we pierce the wrapper and move the value rather than the wrapper. Essentially,
        the only time that we want to visit a variant and not pierce the wrapper,
        is when calling the destructor. When constructing the value that gets moved
        into <span class="bold"><strong>our</strong></span> storage though, this should always
        have a wrapper if appropriate, regardless of what the visited value is. This
        ensures correctness also when we are using the "generalizing" ctors
        of <code class="computeroutput"><span class="identifier">variant</span></code>.
      </p>
<p>
        See the <code class="computeroutput"><span class="identifier">move_constructor</span></code>
        and <code class="computeroutput"><span class="identifier">move_assigner</span></code> visitors
        in <code class="computeroutput"><span class="identifier">variant</span><span class="special">.</span><span class="identifier">hpp</span></code> for complete examples.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../discussion.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../discussion.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="comparison_and_performance_chara.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
