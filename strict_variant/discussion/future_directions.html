<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Future Directions</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../../index.html" title="Chapter&#160;1.&#160;Strict Variant 0.0">
<link rel="up" href="../discussion.html" title="Remarks">
<link rel="prev" href="vistation_benchmarks.html" title="Vistation Benchmarks">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="vistation_benchmarks.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../discussion.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="strict_variant.discussion.future_directions"></a><a class="link" href="future_directions.html" title="Future Directions">Future Directions</a>
</h3></div></div></div>
<h5>
<a name="strict_variant.discussion.future_directions.h0"></a>
        <span><a name="strict_variant.discussion.future_directions.constexpr_support"></a></span><a class="link" href="future_directions.html#strict_variant.discussion.future_directions.constexpr_support"><code class="computeroutput"><span class="keyword">constexpr</span></code> support</a>
      </h5>
<p>
        <code class="computeroutput"><span class="keyword">constexpr</span></code> support is somewhat
        harder to do well at C++11 standard compared to at C++14. And since <code class="computeroutput"><span class="keyword">constexpr</span></code> computations cannot make dynamic
        allocations, it's not consistent with <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        which is somehow an essential component of <code class="computeroutput"><span class="identifier">strict_variant</span></code>.
        Any <code class="computeroutput"><span class="keyword">constexpr</span></code> usage would be
        somewhat orthogonal to the bulk of the development work so far.
      </p>
<p>
        It could be added in the future, but for now we simply use placement-new
        in our storage and there is no <code class="computeroutput"><span class="keyword">constexpr</span></code>
        support.
      </p>
<p>
        If you need this, you might want to take a good look at <code class="computeroutput"><span class="identifier">eggs</span><span class="special">::</span><span class="identifier">variant</span></code>.
      </p>
<h5>
<a name="strict_variant.discussion.future_directions.h1"></a>
        <span><a name="strict_variant.discussion.future_directions.allocator_support"></a></span><a class="link" href="future_directions.html#strict_variant.discussion.future_directions.allocator_support"><code class="computeroutput"><span class="identifier">allocator</span></code> support</a>
      </h5>
<p>
        Since <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code> makes
        dynamic allocations on behalf of the variant, a quite natural refinement
        would be to allow custom allocators to be used with the wrapper.
      </p>
<p>
        Most likely, the allocator should become a template parameter and a member
        of the <code class="computeroutput"><span class="identifier">strict_variant</span></code> itself,
        which then passes it on to any <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        that are constructed. But execution of this plan is left to future work.
      </p>
<h5>
<a name="strict_variant.discussion.future_directions.h2"></a>
        <span><a name="strict_variant.discussion.future_directions.extract_heap_objects"></a></span><a class="link" href="future_directions.html#strict_variant.discussion.future_directions.extract_heap_objects">Extract
        heap objects</a>
      </h5>
<p>
        One way to mitigate the costs of using <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        in the variant would be if it were possible to "take ownership"
        of the dynamic allocation from the variant. The idea would be, once the contained
        type has been determined to be <code class="computeroutput"><span class="identifier">recursive_wrapper</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>,
        we could imagine a function which consumes the variant and yields <code class="computeroutput"><span class="identifier">unique_ptr</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>,
        taking ownership of the pointer that is in storage.
      </p>
<p>
        This is also left to future work.
      </p>
<h5>
<a name="strict_variant.discussion.future_directions.h3"></a>
        <span><a name="strict_variant.discussion.future_directions.support_extended_integer_types"></a></span><a class="link" href="future_directions.html#strict_variant.discussion.future_directions.support_extended_integer_types">Support
        extended integer types</a>
      </h5>
<p>
        Is there a good way that we can potentially extend the "safely_constructible"
        framework to include potential implementation-specific extended integer types?
      </p>
<h5>
<a name="strict_variant.discussion.future_directions.h4"></a>
        <span><a name="strict_variant.discussion.future_directions.improve_noexcept_annotations_of_"></a></span><a class="link" href="future_directions.html#strict_variant.discussion.future_directions.improve_noexcept_annotations_of_">Improve
        <code class="computeroutput"><span class="keyword">noexcept</span></code> annotations of <code class="computeroutput"><span class="identifier">variant</span></code> when using <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>?</a>
      </h5>
<p>
        One of the basic design ideas here is to use <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        when a type has a throwing move.
      </p>
<p>
        However, this has the potential to reduce the quality of our <code class="computeroutput"><span class="keyword">noexcept</span></code> annotations in certain situations.
      </p>
<p>
        The reason is that, <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        is supposed to work also when the type is incomplete -- in that case the
        traits that determine whether special member functions of the variant throw,
        basically have to assume that they might, since we can't check the actual
        type.
      </p>
<p>
        In cases when the type <span class="bold"><strong>is</strong></span> complete, we could
        introduce a different wrapper, say, <code class="computeroutput"><span class="identifier">heap_wrapper</span></code>
        or something, which would be the same, but we would be able to interrogate
        the type to determine situations in which it throws.
      </p>
<p>
        Now, usually you would only use <code class="computeroutput"><span class="identifier">heap_wrapper</span></code>
        when the type has a throwing move, and in that case, it likely also has a
        throwing copy. So not much is likely to be gained by <code class="computeroutput"><span class="identifier">heap_wrapper</span></code>
        here.
      </p>
<p>
        It would be nice if, when <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>
        is used with a type which is incomplete, but doesn't actually throw, we can
        actually deduce that fact. But as far as I know this isn't feasible -- the
        <code class="computeroutput"><span class="keyword">noexcept</span></code> annotations on the
        <code class="computeroutput"><span class="identifier">variant</span></code> special member functions
        must be complete at the point of instantiation of the variant. So we have
        to assume the worst when the user uses <code class="computeroutput"><span class="identifier">recursive_wrapper</span></code>,
        so far as I know.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016 Chris Beck<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="vistation_benchmarks.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../discussion.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a>
</div>
</body>
</html>
